/* tslint:disable */
/* eslint-disable */
/**
 * LaunchDarkly REST API
 * Build custom integrations with the LaunchDarkly REST API
 *
 * The version of the OpenAPI document: 3.8.0
 * Contact: support@launchdarkly.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface AuditLogEntries
 */
export interface AuditLogEntries {
    /**
     * 
     * @type {Links}
     * @memberof AuditLogEntries
     */
    _links?: Links;
    /**
     * 
     * @type {Array<AuditLogEntry>}
     * @memberof AuditLogEntries
     */
    items?: Array<AuditLogEntry>;
}
/**
 * 
 * @export
 * @interface AuditLogEntry
 */
export interface AuditLogEntry {
    /**
     * 
     * @type {Links}
     * @memberof AuditLogEntry
     */
    _links?: Links;
    /**
     * The unique resource id.
     * @type {string}
     * @memberof AuditLogEntry
     */
    _id?: string;
    /**
     * 
     * @type {number}
     * @memberof AuditLogEntry
     */
    date?: number;
    /**
     * 
     * @type {string}
     * @memberof AuditLogEntry
     */
    kind?: string;
    /**
     * 
     * @type {string}
     * @memberof AuditLogEntry
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof AuditLogEntry
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof AuditLogEntry
     */
    shortDescription?: string;
    /**
     * 
     * @type {string}
     * @memberof AuditLogEntry
     */
    comment?: string;
    /**
     * 
     * @type {Member}
     * @memberof AuditLogEntry
     */
    member?: Member;
    /**
     * 
     * @type {string}
     * @memberof AuditLogEntry
     */
    titleVerb?: string;
    /**
     * 
     * @type {string}
     * @memberof AuditLogEntry
     */
    title?: string;
    /**
     * 
     * @type {AuditLogEntryTarget}
     * @memberof AuditLogEntry
     */
    target?: AuditLogEntryTarget;
}
/**
 * 
 * @export
 * @interface AuditLogEntryTarget
 */
export interface AuditLogEntryTarget {
    /**
     * 
     * @type {Links}
     * @memberof AuditLogEntryTarget
     */
    _links?: Links;
    /**
     * 
     * @type {string}
     * @memberof AuditLogEntryTarget
     */
    name?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof AuditLogEntryTarget
     */
    resources?: Array<string>;
}
/**
 * 
 * @export
 * @interface Clause
 */
export interface Clause {
    /**
     * 
     * @type {string}
     * @memberof Clause
     */
    _id?: string;
    /**
     * 
     * @type {string}
     * @memberof Clause
     */
    attribute?: string;
    /**
     * 
     * @type {string}
     * @memberof Clause
     */
    op?: string;
    /**
     * 
     * @type {Array<object>}
     * @memberof Clause
     */
    values?: Array<object>;
    /**
     * 
     * @type {boolean}
     * @memberof Clause
     */
    negate?: boolean;
}
/**
 * 
 * @export
 * @interface ClientSideAvailability
 */
export interface ClientSideAvailability {
    /**
     * When set to true, this flag will be available to SDKs using the client-side id.
     * @type {boolean}
     * @memberof ClientSideAvailability
     */
    usingEnvironmentId?: boolean;
    /**
     * When set to true, this flag will be available to SDKS using a mobile key.
     * @type {boolean}
     * @memberof ClientSideAvailability
     */
    usingMobileKey?: boolean;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum CopyActions {
    UpdateOn = 'updateOn',
    UpdatePrerequisites = 'updatePrerequisites',
    UpdateTargets = 'updateTargets',
    UpdateRules = 'updateRules',
    UpdateFallthrough = 'updateFallthrough',
    UpdateOffVariation = 'updateOffVariation'
}

/**
 * A name and value describing a custom property.
 * @export
 * @interface CustomProperty
 */
export interface CustomProperty {
    /**
     * The name of the property.
     * @type {string}
     * @memberof CustomProperty
     */
    name: string;
    /**
     * Values for this property.
     * @type {Array<string>}
     * @memberof CustomProperty
     */
    value?: Array<string>;
}
/**
 * 
 * @export
 * @interface CustomRole
 */
export interface CustomRole {
    /**
     * 
     * @type {Links}
     * @memberof CustomRole
     */
    _links?: Links;
    /**
     * Name of the custom role.
     * @type {string}
     * @memberof CustomRole
     */
    name?: string;
    /**
     * The 20-hexdigit id or the key for a custom role.
     * @type {string}
     * @memberof CustomRole
     */
    key?: string;
    /**
     * Description of the custom role.
     * @type {string}
     * @memberof CustomRole
     */
    description?: string;
    /**
     * The unique resource id.
     * @type {string}
     * @memberof CustomRole
     */
    _id?: string;
    /**
     * 
     * @type {Array<Policy>}
     * @memberof CustomRole
     */
    policy?: Array<Policy>;
}
/**
 * 
 * @export
 * @interface CustomRoles
 */
export interface CustomRoles {
    /**
     * 
     * @type {Links}
     * @memberof CustomRoles
     */
    _links?: Links;
    /**
     * 
     * @type {Array<CustomRole>}
     * @memberof CustomRoles
     */
    items?: Array<CustomRole>;
}
/**
 * Default values to be used when a new environment is created.
 * @export
 * @interface Defaults
 */
export interface Defaults {
    /**
     * The index of the variation to be served when a flag\'s targeting is on (default variation).
     * @type {number}
     * @memberof Defaults
     */
    onVariation: number;
    /**
     * The index of the variation to be served when a flag is off.
     * @type {number}
     * @memberof Defaults
     */
    offVariation: number;
}
/**
 * 
 * @export
 * @interface Destination
 */
export interface Destination {
    /**
     * 
     * @type {Links}
     * @memberof Destination
     */
    _links?: Links;
    /**
     * Unique destination ID.
     * @type {string}
     * @memberof Destination
     */
    _id?: string;
    /**
     * The destination name
     * @type {string}
     * @memberof Destination
     */
    name?: string;
    /**
     * Destination type (\"google-pubsub\", \"kinesis\", \"mparticle\", or \"segment\")
     * @type {string}
     * @memberof Destination
     */
    kind?: DestinationKindEnum;
    /**
     * destination-specific configuration.
     * @type {object}
     * @memberof Destination
     */
    config?: object;
    /**
     * Whether the data export destination is on or not.
     * @type {boolean}
     * @memberof Destination
     */
    on?: boolean;
    /**
     * 
     * @type {number}
     * @memberof Destination
     */
    version?: number;
}

/**
    * @export
    * @enum {string}
    */
export enum DestinationKindEnum {
    GooglePubsub = 'google-pubsub',
    Kinesis = 'kinesis',
    Mparticle = 'mparticle',
    Segment = 'segment'
}

/**
 * 
 * @export
 * @interface DestinationAmazonKinesis
 */
export interface DestinationAmazonKinesis {
    /**
     * 
     * @type {string}
     * @memberof DestinationAmazonKinesis
     */
    region?: string;
    /**
     * 
     * @type {string}
     * @memberof DestinationAmazonKinesis
     */
    roleArn?: string;
    /**
     * 
     * @type {string}
     * @memberof DestinationAmazonKinesis
     */
    streamName?: string;
}
/**
 * 
 * @export
 * @interface DestinationGooglePubSub
 */
export interface DestinationGooglePubSub {
    /**
     * 
     * @type {string}
     * @memberof DestinationGooglePubSub
     */
    project?: string;
    /**
     * 
     * @type {string}
     * @memberof DestinationGooglePubSub
     */
    topic?: string;
}
/**
 * 
 * @export
 * @interface DestinationMParticle
 */
export interface DestinationMParticle {
    /**
     * 
     * @type {string}
     * @memberof DestinationMParticle
     */
    apiKey?: string;
    /**
     * 
     * @type {string}
     * @memberof DestinationMParticle
     */
    secret?: string;
    /**
     * 
     * @type {string}
     * @memberof DestinationMParticle
     */
    userIdentity?: string;
    /**
     * 
     * @type {string}
     * @memberof DestinationMParticle
     */
    environment?: string;
}
/**
 * 
 * @export
 * @interface DestinationSegment
 */
export interface DestinationSegment {
    /**
     * 
     * @type {string}
     * @memberof DestinationSegment
     */
    writeKey?: string;
}
/**
 * 
 * @export
 * @interface Destinations
 */
export interface Destinations {
    /**
     * 
     * @type {Links}
     * @memberof Destinations
     */
    _links?: Links;
    /**
     * 
     * @type {Array<Destination>}
     * @memberof Destinations
     */
    items?: Array<Destination>;
}
/**
 * 
 * @export
 * @interface Environment
 */
export interface Environment {
    /**
     * 
     * @type {Links}
     * @memberof Environment
     */
    _links?: Links;
    /**
     * The unique resource id.
     * @type {string}
     * @memberof Environment
     */
    _id?: string;
    /**
     * The key for the environment.
     * @type {string}
     * @memberof Environment
     */
    key?: string;
    /**
     * The name of the environment.
     * @type {string}
     * @memberof Environment
     */
    name?: string;
    /**
     * The SDK key for backend LaunchDarkly SDKs.
     * @type {string}
     * @memberof Environment
     */
    apiKey?: string;
    /**
     * The SDK key for mobile LaunchDarkly SDKs.
     * @type {string}
     * @memberof Environment
     */
    mobileKey?: string;
    /**
     * The swatch color for the environment.
     * @type {string}
     * @memberof Environment
     */
    color?: string;
    /**
     * The default TTL.
     * @type {number}
     * @memberof Environment
     */
    defaultTtl?: number;
    /**
     * Determines if this environment is in safe mode.
     * @type {boolean}
     * @memberof Environment
     */
    secureMode?: boolean;
    /**
     * Set to true to send detailed event information for new flags.
     * @type {boolean}
     * @memberof Environment
     */
    defaultTrackEvents?: boolean;
    /**
     * An array of tags for this environment.
     * @type {Array<string>}
     * @memberof Environment
     */
    tags?: Array<string>;
    /**
     * Determines if this environment requires comments for flag and segment changes.
     * @type {boolean}
     * @memberof Environment
     */
    requireComments?: boolean;
    /**
     * Determines if this environment requires confirmation for flag and segment changes.
     * @type {boolean}
     * @memberof Environment
     */
    confirmChanges?: boolean;
}
/**
 * 
 * @export
 * @interface EnvironmentPost
 */
export interface EnvironmentPost {
    /**
     * The name of the new environment.
     * @type {string}
     * @memberof EnvironmentPost
     */
    name: string;
    /**
     * A project-unique key for the new environment.
     * @type {string}
     * @memberof EnvironmentPost
     */
    key: string;
    /**
     * A color swatch (as an RGB hex value with no leading \'#\', e.g. C8C8C8).
     * @type {string}
     * @memberof EnvironmentPost
     */
    color: string;
    /**
     * The default TTL for the new environment.
     * @type {number}
     * @memberof EnvironmentPost
     */
    defaultTtl?: number;
    /**
     * Determines whether the environment is in secure mode.
     * @type {boolean}
     * @memberof EnvironmentPost
     */
    secureMode?: boolean;
    /**
     * Set to true to send detailed event information for newly created flags.
     * @type {boolean}
     * @memberof EnvironmentPost
     */
    defaultTrackEvents?: boolean;
    /**
     * An array of tags for this environment.
     * @type {Array<string>}
     * @memberof EnvironmentPost
     */
    tags?: Array<string>;
    /**
     * Determines if this environment requires comments for flag and segment changes.
     * @type {boolean}
     * @memberof EnvironmentPost
     */
    requireComments?: boolean;
    /**
     * Determines if this environment requires confirmation for flag and segment changes.
     * @type {boolean}
     * @memberof EnvironmentPost
     */
    confirmChanges?: boolean;
}
/**
 * 
 * @export
 * @interface EvaluationUsageError
 */
export interface EvaluationUsageError {
    /**
     * 
     * @type {string}
     * @memberof EvaluationUsageError
     */
    code?: string;
    /**
     * 
     * @type {string}
     * @memberof EvaluationUsageError
     */
    message?: string;
}
/**
 * 
 * @export
 * @interface Events
 */
export interface Events {
    /**
     * 
     * @type {UsageLinks}
     * @memberof Events
     */
    links?: UsageLinks;
}
/**
 * 
 * @export
 * @interface Fallthrough
 */
export interface Fallthrough {
    /**
     * 
     * @type {number}
     * @memberof Fallthrough
     */
    variation?: number;
    /**
     * 
     * @type {Rollout}
     * @memberof Fallthrough
     */
    rollout?: Rollout;
}
/**
 * 
 * @export
 * @interface FeatureFlag
 */
export interface FeatureFlag {
    /**
     * 
     * @type {string}
     * @memberof FeatureFlag
     */
    key?: string;
    /**
     * Name of the feature flag.
     * @type {string}
     * @memberof FeatureFlag
     */
    name?: string;
    /**
     * Description of the feature flag.
     * @type {string}
     * @memberof FeatureFlag
     */
    description?: string;
    /**
     * Whether the feature flag is a boolean flag or multivariate.
     * @type {string}
     * @memberof FeatureFlag
     */
    kind?: string;
    /**
     * A unix epoch time in milliseconds specifying the creation time of this flag.
     * @type {number}
     * @memberof FeatureFlag
     */
    creationDate?: number;
    /**
     * 
     * @type {boolean}
     * @memberof FeatureFlag
     */
    includeInSnippet?: boolean;
    /**
     * Whether or not this flag is temporary.
     * @type {boolean}
     * @memberof FeatureFlag
     */
    temporary?: boolean;
    /**
     * The ID of the member that should maintain this flag.
     * @type {string}
     * @memberof FeatureFlag
     */
    maintainerId?: string;
    /**
     * An array of tags for this feature flag.
     * @type {Array<string>}
     * @memberof FeatureFlag
     */
    tags?: Array<string>;
    /**
     * The variations for this feature flag.
     * @type {Array<Variation>}
     * @memberof FeatureFlag
     */
    variations?: Array<Variation>;
    /**
     * An array goals from all environments associated with this feature flag
     * @type {Array<string>}
     * @memberof FeatureFlag
     */
    goalIds?: Array<string>;
    /**
     * 
     * @type {number}
     * @memberof FeatureFlag
     */
    _version?: number;
    /**
     * A mapping of keys to CustomProperty entries.
     * @type {{ [key: string]: CustomProperty; }}
     * @memberof FeatureFlag
     */
    customProperties?: { [key: string]: CustomProperty; };
    /**
     * 
     * @type {Links}
     * @memberof FeatureFlag
     */
    _links?: Links;
    /**
     * 
     * @type {Member}
     * @memberof FeatureFlag
     */
    _maintainer?: Member;
    /**
     * 
     * @type {{ [key: string]: FeatureFlagConfig; }}
     * @memberof FeatureFlag
     */
    environments?: { [key: string]: FeatureFlagConfig; };
    /**
     * A unix epoch time in milliseconds specifying the archived time of this flag.
     * @type {number}
     * @memberof FeatureFlag
     */
    archivedDate?: number;
    /**
     * Whether or not this flag is archived.
     * @type {boolean}
     * @memberof FeatureFlag
     */
    archived?: boolean;
    /**
     * 
     * @type {ClientSideAvailability}
     * @memberof FeatureFlag
     */
    clientSideAvailability?: ClientSideAvailability;
    /**
     * 
     * @type {Defaults}
     * @memberof FeatureFlag
     */
    defaults?: Defaults;
}
/**
 * 
 * @export
 * @interface FeatureFlagConfig
 */
export interface FeatureFlagConfig {
    /**
     * 
     * @type {boolean}
     * @memberof FeatureFlagConfig
     */
    on?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof FeatureFlagConfig
     */
    archived?: boolean;
    /**
     * 
     * @type {string}
     * @memberof FeatureFlagConfig
     */
    salt?: string;
    /**
     * 
     * @type {string}
     * @memberof FeatureFlagConfig
     */
    sel?: string;
    /**
     * 
     * @type {number}
     * @memberof FeatureFlagConfig
     */
    lastModified?: number;
    /**
     * 
     * @type {number}
     * @memberof FeatureFlagConfig
     */
    version?: number;
    /**
     * 
     * @type {Array<Target>}
     * @memberof FeatureFlagConfig
     */
    targets?: Array<Target>;
    /**
     * 
     * @type {Array<Rule>}
     * @memberof FeatureFlagConfig
     */
    rules?: Array<Rule>;
    /**
     * 
     * @type {Fallthrough}
     * @memberof FeatureFlagConfig
     */
    fallthrough?: Fallthrough;
    /**
     * 
     * @type {number}
     * @memberof FeatureFlagConfig
     */
    offVariation?: number;
    /**
     * 
     * @type {Array<Prerequisite>}
     * @memberof FeatureFlagConfig
     */
    prerequisites?: Array<Prerequisite>;
    /**
     * Set to true to send detailed event information for this flag.
     * @type {boolean}
     * @memberof FeatureFlagConfig
     */
    trackEvents?: boolean;
    /**
     * Set to true to send detailed event information when targeting is enabled but no individual targeting rule is matched.
     * @type {boolean}
     * @memberof FeatureFlagConfig
     */
    trackEventsFallthrough?: boolean;
}
/**
 * 
 * @export
 * @interface FeatureFlagCopyObject
 */
export interface FeatureFlagCopyObject {
    /**
     * The environment key to be used.
     * @type {string}
     * @memberof FeatureFlagCopyObject
     */
    key: string;
    /**
     * If the latest version of the flag matches provided version it will copy, otherwise it will return a conflict.
     * @type {number}
     * @memberof FeatureFlagCopyObject
     */
    currentVersion?: number;
}
/**
 * 
 * @export
 * @interface FeatureFlagScheduledChange
 */
export interface FeatureFlagScheduledChange {
    /**
     * A unix epoch time in milliseconds specifying the date the scheduled changes will be applied
     * @type {number}
     * @memberof FeatureFlagScheduledChange
     */
    executionDate?: number;
    /**
     * 
     * @type {number}
     * @memberof FeatureFlagScheduledChange
     */
    _version?: number;
    /**
     * 
     * @type {string}
     * @memberof FeatureFlagScheduledChange
     */
    _id?: string;
    /**
     * 
     * @type {Array<object>}
     * @memberof FeatureFlagScheduledChange
     */
    instructions?: Array<object>;
}
/**
 * 
 * @export
 * @interface FeatureFlagScheduledChanges
 */
export interface FeatureFlagScheduledChanges {
    /**
     * 
     * @type {Links}
     * @memberof FeatureFlagScheduledChanges
     */
    _links?: Links;
    /**
     * 
     * @type {Array<FeatureFlagScheduledChange>}
     * @memberof FeatureFlagScheduledChanges
     */
    items?: Array<FeatureFlagScheduledChange>;
}
/**
 * 
 * @export
 * @interface FeatureFlagScheduledChangesConflicts
 */
export interface FeatureFlagScheduledChangesConflicts {
    /**
     * 
     * @type {Array<FeatureFlagScheduledChangesConflictsInstructions>}
     * @memberof FeatureFlagScheduledChangesConflicts
     */
    instructions?: Array<FeatureFlagScheduledChangesConflictsInstructions>;
}
/**
 * 
 * @export
 * @interface FeatureFlagScheduledChangesConflictsInstructions
 */
export interface FeatureFlagScheduledChangesConflictsInstructions {
    /**
     * The name of the modification you would like to perform on a resource.
     * @type {string}
     * @memberof FeatureFlagScheduledChangesConflictsInstructions
     */
    kind?: string;
    /**
     * 
     * @type {Array<ScheduledChangesFeatureFlagConflict>}
     * @memberof FeatureFlagScheduledChangesConflictsInstructions
     */
    conflicts?: Array<ScheduledChangesFeatureFlagConflict>;
}
/**
 * 
 * @export
 * @interface FeatureFlagStatus
 */
export interface FeatureFlagStatus {
    /**
     * | Name     | Description | | --------:| ----------- | | new      | the feature flag was created within the last 7 days, and has not been requested yet | | active   | the feature flag was requested by your servers or clients within the last 7 days | | inactive | the feature flag was created more than 7 days ago, and hasn\'t been requested by your servers or clients within the past 7 days | | launched | one variation of the feature flag has been rolled out to all your users for at least 7 days | 
     * @type {string}
     * @memberof FeatureFlagStatus
     */
    name?: FeatureFlagStatusNameEnum;
    /**
     * 
     * @type {string}
     * @memberof FeatureFlagStatus
     */
    lastRequested?: string;
    /**
     * 
     * @type {object}
     * @memberof FeatureFlagStatus
     */
    _default?: object;
    /**
     * 
     * @type {Links}
     * @memberof FeatureFlagStatus
     */
    _links?: Links;
}

/**
    * @export
    * @enum {string}
    */
export enum FeatureFlagStatusNameEnum {
    New = 'new',
    Active = 'active',
    Inactive = 'inactive',
    Launched = 'launched'
}

/**
 * 
 * @export
 * @interface FeatureFlagStatusAcrossEnvironments
 */
export interface FeatureFlagStatusAcrossEnvironments {
    /**
     * 
     * @type {Links}
     * @memberof FeatureFlagStatusAcrossEnvironments
     */
    _links?: Links;
    /**
     * 
     * @type {string}
     * @memberof FeatureFlagStatusAcrossEnvironments
     */
    key?: string;
    /**
     * 
     * @type {{ [key: string]: FeatureFlagStatusForQueriedEnvironment; }}
     * @memberof FeatureFlagStatusAcrossEnvironments
     */
    environments?: { [key: string]: FeatureFlagStatusForQueriedEnvironment; };
}
/**
 * 
 * @export
 * @interface FeatureFlagStatusForQueriedEnvironment
 */
export interface FeatureFlagStatusForQueriedEnvironment {
    /**
     * | Name     | Description | | --------:| ----------- | | new      | the feature flag was created within the last 7 days, and has not been requested yet | | active   | the feature flag was requested by your servers or clients within the last 7 days | | inactive | the feature flag was created more than 7 days ago, and hasn\'t been requested by your servers or clients within the past 7 days | | launched | one variation of the feature flag has been rolled out to all your users for at least 7 days | 
     * @type {string}
     * @memberof FeatureFlagStatusForQueriedEnvironment
     */
    name?: FeatureFlagStatusForQueriedEnvironmentNameEnum;
    /**
     * 
     * @type {string}
     * @memberof FeatureFlagStatusForQueriedEnvironment
     */
    lastRequested?: string;
    /**
     * 
     * @type {object}
     * @memberof FeatureFlagStatusForQueriedEnvironment
     */
    _default?: object;
}

/**
    * @export
    * @enum {string}
    */
export enum FeatureFlagStatusForQueriedEnvironmentNameEnum {
    New = 'new',
    Active = 'active',
    Inactive = 'inactive',
    Launched = 'launched'
}

/**
 * 
 * @export
 * @interface FeatureFlagStatuses
 */
export interface FeatureFlagStatuses {
    /**
     * 
     * @type {Links}
     * @memberof FeatureFlagStatuses
     */
    _links?: Links;
    /**
     * 
     * @type {Array<FeatureFlagStatus>}
     * @memberof FeatureFlagStatuses
     */
    items?: Array<FeatureFlagStatus>;
}
/**
 * 
 * @export
 * @interface FeatureFlags
 */
export interface FeatureFlags {
    /**
     * 
     * @type {Links}
     * @memberof FeatureFlags
     */
    _links?: Links;
    /**
     * 
     * @type {Array<FeatureFlag>}
     * @memberof FeatureFlags
     */
    items?: Array<FeatureFlag>;
    /**
     * 
     * @type {number}
     * @memberof FeatureFlags
     */
    totalCount?: number;
}
/**
 * 
 * @export
 * @interface FlagListItem
 */
export interface FlagListItem {
    /**
     * 
     * @type {string}
     * @memberof FlagListItem
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof FlagListItem
     */
    key?: string;
    /**
     * 
     * @type {Links}
     * @memberof FlagListItem
     */
    _links?: Links;
    /**
     * 
     * @type {Site}
     * @memberof FlagListItem
     */
    _site?: Site;
}
/**
 * 
 * @export
 * @interface HierarchicalLinks
 */
export interface HierarchicalLinks {
    /**
     * 
     * @type {Link}
     * @memberof HierarchicalLinks
     */
    parent?: Link;
    /**
     * 
     * @type {Link}
     * @memberof HierarchicalLinks
     */
    self?: Link;
}
/**
 * 
 * @export
 * @interface InlineObject
 */
export interface InlineObject {
    /**
     * 
     * @type {string}
     * @memberof InlineObject
     */
    email: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject
     */
    firstName?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject
     */
    lastName?: string;
    /**
     * 
     * @type {Role}
     * @memberof InlineObject
     */
    role?: Role;
    /**
     * 
     * @type {Array<string>}
     * @memberof InlineObject
     */
    customRoles?: Array<string>;
    /**
     * 
     * @type {Array<Statement>}
     * @memberof InlineObject
     */
    inlineRole?: Array<Statement>;
}
/**
 * 
 * @export
 * @interface InlineObject1
 */
export interface InlineObject1 {
    /**
     * A human-friendly name for the feature flag. Remember to note if this flag is intended to be temporary or permanent.
     * @type {string}
     * @memberof InlineObject1
     */
    name: string;
    /**
     * A unique key that will be used to reference the flag in your code.
     * @type {string}
     * @memberof InlineObject1
     */
    key: string;
    /**
     * A description of the feature flag.
     * @type {string}
     * @memberof InlineObject1
     */
    description?: string;
    /**
     * An array of possible variations for the flag.
     * @type {Array<Variation>}
     * @memberof InlineObject1
     */
    variations: Array<Variation>;
    /**
     * Whether or not the flag is a temporary flag.
     * @type {boolean}
     * @memberof InlineObject1
     */
    temporary?: boolean;
    /**
     * Tags for the feature flag.
     * @type {Array<string>}
     * @memberof InlineObject1
     */
    tags?: Array<string>;
    /**
     * Whether or not this flag should be made available to the client-side JavaScript SDK.
     * @type {boolean}
     * @memberof InlineObject1
     */
    includeInSnippet?: boolean;
    /**
     * 
     * @type {ClientSideAvailability}
     * @memberof InlineObject1
     */
    clientSideAvailability?: ClientSideAvailability;
    /**
     * 
     * @type {Defaults}
     * @memberof InlineObject1
     */
    defaults?: Defaults;
}
/**
 * 
 * @export
 * @interface InlineObject10
 */
export interface InlineObject10 {
    /**
     * A human-friendly name for the access token
     * @type {string}
     * @memberof InlineObject10
     */
    name?: string;
    /**
     * The name of a built-in role for the token
     * @type {string}
     * @memberof InlineObject10
     */
    role?: string;
    /**
     * A list of custom role IDs to use as access limits for the access token
     * @type {Array<string>}
     * @memberof InlineObject10
     */
    customRoleIds?: Array<string>;
    /**
     * 
     * @type {Array<Statement>}
     * @memberof InlineObject10
     */
    inlineRole?: Array<Statement>;
    /**
     * Whether the token will be a service token https://docs.launchdarkly.com/home/account-security/api-access-tokens#service-tokens
     * @type {boolean}
     * @memberof InlineObject10
     */
    serviceToken?: boolean;
    /**
     * The default API version for this token
     * @type {number}
     * @memberof InlineObject10
     */
    defaultApiVersion?: number;
}
/**
 * 
 * @export
 * @interface InlineObject11
 */
export interface InlineObject11 {
    /**
     * A human-friendly name for the relay proxy configuration
     * @type {string}
     * @memberof InlineObject11
     */
    name?: string;
    /**
     * 
     * @type {Array<Policy>}
     * @memberof InlineObject11
     */
    policy?: Array<Policy>;
}
/**
 * 
 * @export
 * @interface InlineObject12
 */
export interface InlineObject12 {
    /**
     * A human-readable name for your subscription configuration.
     * @type {string}
     * @memberof InlineObject12
     */
    name: string;
    /**
     * 
     * @type {Array<Statement>}
     * @memberof InlineObject12
     */
    statements?: Array<Statement>;
    /**
     * Integration-specific configuration fields.
     * @type {object}
     * @memberof InlineObject12
     */
    config: object;
    /**
     * Whether the integration subscription is active or not.
     * @type {boolean}
     * @memberof InlineObject12
     */
    on?: boolean;
    /**
     * Tags for the integration subscription.
     * @type {Array<string>}
     * @memberof InlineObject12
     */
    tags?: Array<string>;
}
/**
 * 
 * @export
 * @interface InlineObject2
 */
export interface InlineObject2 {
    /**
     * 
     * @type {string}
     * @memberof InlineObject2
     */
    comment?: string;
    /**
     * 
     * @type {Array<PatchOperation>}
     * @memberof InlineObject2
     */
    patch?: Array<PatchOperation>;
}
/**
 * 
 * @export
 * @interface InlineObject3
 */
export interface InlineObject3 {
    /**
     * 
     * @type {FeatureFlagCopyObject}
     * @memberof InlineObject3
     */
    source?: FeatureFlagCopyObject;
    /**
     * 
     * @type {FeatureFlagCopyObject}
     * @memberof InlineObject3
     */
    target?: FeatureFlagCopyObject;
    /**
     * comment will be included in audit log item for change.
     * @type {string}
     * @memberof InlineObject3
     */
    comment?: string;
    /**
     * Define the parts of the flag configuration that will be copied.
     * @type {Array<CopyActions>}
     * @memberof InlineObject3
     */
    includedActions?: Array<CopyActions>;
    /**
     * Define the parts of the flag configuration that will not be copied.
     * @type {Array<CopyActions>}
     * @memberof InlineObject3
     */
    excludedActions?: Array<CopyActions>;
}
/**
 * 
 * @export
 * @interface InlineObject4
 */
export interface InlineObject4 {
    /**
     * A human-friendly name for the user segment.
     * @type {string}
     * @memberof InlineObject4
     */
    name: string;
    /**
     * A unique key that will be used to reference the user segment in feature flags.
     * @type {string}
     * @memberof InlineObject4
     */
    key: string;
    /**
     * A description for the user segment.
     * @type {string}
     * @memberof InlineObject4
     */
    description?: string;
    /**
     * Controls whether this segment can support unlimited numbers of users. Requires the beta API and additional setup. Include/exclude lists in this payload are not used in unbounded segments.
     * @type {boolean}
     * @memberof InlineObject4
     */
    unbounded?: boolean;
    /**
     * Tags for the user segment.
     * @type {Array<string>}
     * @memberof InlineObject4
     */
    tags?: Array<string>;
}
/**
 * 
 * @export
 * @interface InlineObject5
 */
export interface InlineObject5 {
    /**
     * 
     * @type {UnboundedSegmentTargetChanges}
     * @memberof InlineObject5
     */
    included?: UnboundedSegmentTargetChanges;
    /**
     * 
     * @type {UnboundedSegmentTargetChanges}
     * @memberof InlineObject5
     */
    excluded?: UnboundedSegmentTargetChanges;
}
/**
 * 
 * @export
 * @interface InlineObject6
 */
export interface InlineObject6 {
    /**
     * The variation value to set for the user. Must match the variation type of the flag. 
     * @type {boolean}
     * @memberof InlineObject6
     */
    setting?: boolean;
}
/**
 * 
 * @export
 * @interface InlineObject7
 */
export interface InlineObject7 {
    /**
     * The URL of the remote webhook.
     * @type {string}
     * @memberof InlineObject7
     */
    url: string;
    /**
     * If sign is true, and the secret attribute is omitted, LaunchDarkly will automatically generate a secret for you.
     * @type {string}
     * @memberof InlineObject7
     */
    secret?: string;
    /**
     * If sign is false, the webhook will not include a signature header, and the secret can be omitted.
     * @type {boolean}
     * @memberof InlineObject7
     */
    sign: boolean;
    /**
     * Whether this webhook is enabled or not.
     * @type {boolean}
     * @memberof InlineObject7
     */
    on: boolean;
    /**
     * The name of the webhook.
     * @type {string}
     * @memberof InlineObject7
     */
    name?: string;
    /**
     * 
     * @type {Array<Statement>}
     * @memberof InlineObject7
     */
    statements?: Array<Statement>;
    /**
     * Tags for the webhook.
     * @type {Array<string>}
     * @memberof InlineObject7
     */
    tags?: Array<string>;
}
/**
 * 
 * @export
 * @interface InlineObject8
 */
export interface InlineObject8 {
    /**
     * Name of the custom role.
     * @type {string}
     * @memberof InlineObject8
     */
    name: string;
    /**
     * Description of the custom role.
     * @type {string}
     * @memberof InlineObject8
     */
    description?: string;
    /**
     * The 20-hexdigit id or the key for a custom role.
     * @type {string}
     * @memberof InlineObject8
     */
    key: string;
    /**
     * 
     * @type {Array<Policy>}
     * @memberof InlineObject8
     */
    policy: Array<Policy>;
}
/**
 * 
 * @export
 * @interface InlineObject9
 */
export interface InlineObject9 {
    /**
     * A human-readable name for your data export destination.
     * @type {string}
     * @memberof InlineObject9
     */
    name: string;
    /**
     * The data export destination type. Available choices are kinesis, google-pubsub, mparticle, or segment.
     * @type {string}
     * @memberof InlineObject9
     */
    kind: InlineObject9KindEnum;
    /**
     * destination-specific configuration.
     * @type {object}
     * @memberof InlineObject9
     */
    config: object;
    /**
     * Whether the data export destination is on or not.
     * @type {boolean}
     * @memberof InlineObject9
     */
    on?: boolean;
}

/**
    * @export
    * @enum {string}
    */
export enum InlineObject9KindEnum {
    GooglePubsub = 'google-pubsub',
    Kinesis = 'kinesis',
    Mparticle = 'mparticle',
    Segment = 'segment'
}

/**
 * 
 * @export
 * @interface Integration
 */
export interface Integration {
    /**
     * 
     * @type {IntegrationLinks}
     * @memberof Integration
     */
    _links?: IntegrationLinks;
    /**
     * 
     * @type {Array<IntegrationSubscription>}
     * @memberof Integration
     */
    items?: Array<IntegrationSubscription>;
}
/**
 * 
 * @export
 * @interface IntegrationLinks
 */
export interface IntegrationLinks {
    /**
     * 
     * @type {Link}
     * @memberof IntegrationLinks
     */
    self?: Link;
}
/**
 * 
 * @export
 * @interface IntegrationSubscription
 */
export interface IntegrationSubscription {
    /**
     * 
     * @type {HierarchicalLinks}
     * @memberof IntegrationSubscription
     */
    _links?: HierarchicalLinks;
    /**
     * The unique resource id.
     * @type {string}
     * @memberof IntegrationSubscription
     */
    _id?: string;
    /**
     * The type of integration associated with this configuration.
     * @type {string}
     * @memberof IntegrationSubscription
     */
    kind?: string;
    /**
     * The user-defined name associated with this configuration.
     * @type {string}
     * @memberof IntegrationSubscription
     */
    name?: string;
    /**
     * A key-value mapping of configuration fields.
     * @type {object}
     * @memberof IntegrationSubscription
     */
    config?: object;
    /**
     * 
     * @type {Array<Statement>}
     * @memberof IntegrationSubscription
     */
    statements?: Array<Statement>;
    /**
     * Whether or not the integration is currently active.
     * @type {boolean}
     * @memberof IntegrationSubscription
     */
    on?: boolean;
    /**
     * An array of tags for this integration configuration.
     * @type {Array<string>}
     * @memberof IntegrationSubscription
     */
    tags?: Array<string>;
    /**
     * 
     * @type {IntegrationSubscriptionStatus}
     * @memberof IntegrationSubscription
     */
    _status?: IntegrationSubscriptionStatus;
}
/**
 * 
 * @export
 * @interface IntegrationSubscriptionStatus
 */
export interface IntegrationSubscriptionStatus {
    /**
     * 
     * @type {number}
     * @memberof IntegrationSubscriptionStatus
     */
    successCount?: number;
    /**
     * A unix epoch time in milliseconds specifying the last time this integration was successfully used.
     * @type {number}
     * @memberof IntegrationSubscriptionStatus
     */
    lastSuccess?: number;
    /**
     * 
     * @type {number}
     * @memberof IntegrationSubscriptionStatus
     */
    errorCount?: number;
}
/**
 * 
 * @export
 * @interface Integrations
 */
export interface Integrations {
    /**
     * A mapping of integration types to their respective API endpoints.
     * @type {object}
     * @memberof Integrations
     */
    _links?: object;
    /**
     * 
     * @type {Array<IntegrationSubscription>}
     * @memberof Integrations
     */
    items?: Array<IntegrationSubscription>;
}
/**
 * 
 * @export
 * @interface Link
 */
export interface Link {
    /**
     * 
     * @type {string}
     * @memberof Link
     */
    href?: string;
    /**
     * 
     * @type {string}
     * @memberof Link
     */
    type?: string;
}
/**
 * 
 * @export
 * @interface Links
 */
export interface Links {
    /**
     * 
     * @type {Link}
     * @memberof Links
     */
    self?: Link;
    /**
     * 
     * @type {Link}
     * @memberof Links
     */
    next?: Link;
}
/**
 * 
 * @export
 * @interface MAU
 */
export interface MAU {
    /**
     * 
     * @type {UsageLinks}
     * @memberof MAU
     */
    _links?: UsageLinks;
    /**
     * 
     * @type {Array<StreamBySDKLinksMetadata>}
     * @memberof MAU
     */
    metadata?: Array<StreamBySDKLinksMetadata>;
    /**
     * 
     * @type {Array<StreamUsageSeries>}
     * @memberof MAU
     */
    series?: Array<StreamUsageSeries>;
}
/**
 * 
 * @export
 * @interface MAUbyCategory
 */
export interface MAUbyCategory {
    /**
     * 
     * @type {StreamBySDKLinks}
     * @memberof MAUbyCategory
     */
    _links?: StreamBySDKLinks;
    /**
     * 
     * @type {Array<object>}
     * @memberof MAUbyCategory
     */
    metadata?: Array<object>;
    /**
     * 
     * @type {Array<StreamUsageSeries>}
     * @memberof MAUbyCategory
     */
    series?: Array<StreamUsageSeries>;
}
/**
 * 
 * @export
 * @interface Member
 */
export interface Member {
    /**
     * 
     * @type {Links}
     * @memberof Member
     */
    _links?: Links;
    /**
     * The unique resource id.
     * @type {string}
     * @memberof Member
     */
    _id?: string;
    /**
     * 
     * @type {Role}
     * @memberof Member
     */
    role?: Role;
    /**
     * 
     * @type {string}
     * @memberof Member
     */
    email?: string;
    /**
     * 
     * @type {string}
     * @memberof Member
     */
    firstName?: string;
    /**
     * 
     * @type {string}
     * @memberof Member
     */
    lastName?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Member
     */
    _verified?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Member
     */
    _pendingInvite?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Member
     */
    isBeta?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof Member
     */
    customRoles?: Array<string>;
}
/**
 * 
 * @export
 * @interface Members
 */
export interface Members {
    /**
     * 
     * @type {Links}
     * @memberof Members
     */
    _links?: Links;
    /**
     * 
     * @type {Array<Member>}
     * @memberof Members
     */
    items?: Array<Member>;
    /**
     * 
     * @type {number}
     * @memberof Members
     */
    totalCount?: number;
}
/**
 * 
 * @export
 * @interface PatchOperation
 */
export interface PatchOperation {
    /**
     * 
     * @type {string}
     * @memberof PatchOperation
     */
    op: string;
    /**
     * 
     * @type {string}
     * @memberof PatchOperation
     */
    path: string;
    /**
     * 
     * @type {object}
     * @memberof PatchOperation
     */
    value: object;
}
/**
 * 
 * @export
 * @interface Policy
 */
export interface Policy {
    /**
     * 
     * @type {Array<string>}
     * @memberof Policy
     */
    resources?: Array<string>;
    /**
     * Targeted resource will be those resources NOT in this list. The \"resources`\" field must be empty to use this field.
     * @type {Array<string>}
     * @memberof Policy
     */
    notResources?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof Policy
     */
    actions?: Array<string>;
    /**
     * Targeted actions will be those actions NOT in this list. The \"actions\" field must be empty to use this field.
     * @type {Array<string>}
     * @memberof Policy
     */
    notActions?: Array<string>;
    /**
     * Effect of the policy - allow or deny.
     * @type {string}
     * @memberof Policy
     */
    effect?: string;
}
/**
 * 
 * @export
 * @interface Prerequisite
 */
export interface Prerequisite {
    /**
     * 
     * @type {string}
     * @memberof Prerequisite
     */
    key?: string;
    /**
     * 
     * @type {number}
     * @memberof Prerequisite
     */
    variation?: number;
}
/**
 * 
 * @export
 * @interface Project
 */
export interface Project {
    /**
     * 
     * @type {Links}
     * @memberof Project
     */
    _links?: Links;
    /**
     * The unique resource id.
     * @type {string}
     * @memberof Project
     */
    _id?: string;
    /**
     * 
     * @type {string}
     * @memberof Project
     */
    key?: string;
    /**
     * 
     * @type {string}
     * @memberof Project
     */
    name?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Project
     */
    includeInSnippetByDefault?: boolean;
    /**
     * 
     * @type {Array<Environment>}
     * @memberof Project
     */
    environments?: Array<Environment>;
    /**
     * An array of tags for this project.
     * @type {Array<string>}
     * @memberof Project
     */
    tags?: Array<string>;
    /**
     * 
     * @type {ClientSideAvailability}
     * @memberof Project
     */
    defaultClientSideAvailability?: ClientSideAvailability;
}
/**
 * 
 * @export
 * @interface Projects
 */
export interface Projects {
    /**
     * 
     * @type {Links}
     * @memberof Projects
     */
    _links?: Links;
    /**
     * 
     * @type {Array<Project>}
     * @memberof Projects
     */
    items?: Array<Project>;
}
/**
 * 
 * @export
 * @interface RelayProxyConfig
 */
export interface RelayProxyConfig {
    /**
     * The unique resource id.
     * @type {string}
     * @memberof RelayProxyConfig
     */
    _id: string;
    /**
     * 
     * @type {Member}
     * @memberof RelayProxyConfig
     */
    _creator: Member;
    /**
     * A human-friendly name for the relay proxy configuration
     * @type {string}
     * @memberof RelayProxyConfig
     */
    name: string;
    /**
     * 
     * @type {Array<Policy>}
     * @memberof RelayProxyConfig
     */
    policy: Array<Policy>;
    /**
     * Full secret key. Only included if creating or resetting the relay proxy configuration
     * @type {string}
     * @memberof RelayProxyConfig
     */
    fullKey?: string;
    /**
     * The last 4 digits of the unique secret key for this relay proxy configuration
     * @type {string}
     * @memberof RelayProxyConfig
     */
    displayKey: string;
    /**
     * A unix epoch time in milliseconds specifying the creation time of this relay proxy configuration
     * @type {number}
     * @memberof RelayProxyConfig
     */
    creationDate: number;
    /**
     * A unix epoch time in milliseconds specifying the last time this relay proxy configuration was modified
     * @type {number}
     * @memberof RelayProxyConfig
     */
    lastModified: number;
}
/**
 * 
 * @export
 * @interface RelayProxyConfigs
 */
export interface RelayProxyConfigs {
    /**
     * 
     * @type {Array<RelayProxyConfig>}
     * @memberof RelayProxyConfigs
     */
    items?: Array<RelayProxyConfig>;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum Role {
    Writer = 'writer',
    Reader = 'reader',
    Admin = 'admin',
    Owner = 'owner'
}

/**
 * 
 * @export
 * @interface Rollout
 */
export interface Rollout {
    /**
     * 
     * @type {string}
     * @memberof Rollout
     */
    bucketBy?: string;
    /**
     * 
     * @type {Array<WeightedVariation>}
     * @memberof Rollout
     */
    variations?: Array<WeightedVariation>;
}
/**
 * 
 * @export
 * @interface Rule
 */
export interface Rule {
    /**
     * 
     * @type {string}
     * @memberof Rule
     */
    _id?: string;
    /**
     * 
     * @type {number}
     * @memberof Rule
     */
    variation?: number;
    /**
     * 
     * @type {boolean}
     * @memberof Rule
     */
    trackEvents?: boolean;
    /**
     * 
     * @type {Rollout}
     * @memberof Rule
     */
    rollout?: Rollout;
    /**
     * 
     * @type {Array<Clause>}
     * @memberof Rule
     */
    clauses?: Array<Clause>;
}
/**
 * 
 * @export
 * @interface ScheduledChangesFeatureFlagConflict
 */
export interface ScheduledChangesFeatureFlagConflict {
    /**
     * Feature flag scheduled change id this change will conflict with
     * @type {string}
     * @memberof ScheduledChangesFeatureFlagConflict
     */
    _id?: string;
    /**
     * Feature flag scheduled change conflict reason
     * @type {string}
     * @memberof ScheduledChangesFeatureFlagConflict
     */
    reason?: string;
}
/**
 * 
 * @export
 * @interface SemanticPatchOperation
 */
export interface SemanticPatchOperation {
    /**
     * 
     * @type {string}
     * @memberof SemanticPatchOperation
     */
    comment?: string;
    /**
     * 
     * @type {Array<object>}
     * @memberof SemanticPatchOperation
     */
    instructions: Array<object>;
}
/**
 * 
 * @export
 * @interface Site
 */
export interface Site {
    /**
     * 
     * @type {string}
     * @memberof Site
     */
    href?: string;
    /**
     * 
     * @type {string}
     * @memberof Site
     */
    type?: string;
}
/**
 * 
 * @export
 * @interface Statement
 */
export interface Statement {
    /**
     * 
     * @type {Array<string>}
     * @memberof Statement
     */
    resources?: Array<string>;
    /**
     * Targeted resource will be those resources NOT in this list. The \"resources`\" field must be empty to use this field.
     * @type {Array<string>}
     * @memberof Statement
     */
    notResources?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof Statement
     */
    actions?: Array<string>;
    /**
     * Targeted actions will be those actions NOT in this list. The \"actions\" field must be empty to use this field.
     * @type {Array<string>}
     * @memberof Statement
     */
    notActions?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof Statement
     */
    effect?: StatementEffectEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum StatementEffectEnum {
    Allow = 'allow',
    Deny = 'deny'
}

/**
 * 
 * @export
 * @interface Stream
 */
export interface Stream {
    /**
     * 
     * @type {StreamUsageLinks}
     * @memberof Stream
     */
    _links?: StreamUsageLinks;
    /**
     * 
     * @type {Array<StreamUsageMetadata>}
     * @memberof Stream
     */
    metadata?: Array<StreamUsageMetadata>;
    /**
     * 
     * @type {Array<StreamUsageSeries>}
     * @memberof Stream
     */
    series?: Array<StreamUsageSeries>;
}
/**
 * 
 * @export
 * @interface StreamBySDK
 */
export interface StreamBySDK {
    /**
     * 
     * @type {StreamBySDKLinks}
     * @memberof StreamBySDK
     */
    _links?: StreamBySDKLinks;
    /**
     * 
     * @type {Array<StreamBySDKLinksMetadata>}
     * @memberof StreamBySDK
     */
    metadata?: Array<StreamBySDKLinksMetadata>;
    /**
     * 
     * @type {Array<StreamUsageSeries>}
     * @memberof StreamBySDK
     */
    series?: Array<StreamUsageSeries>;
}
/**
 * 
 * @export
 * @interface StreamBySDKLinks
 */
export interface StreamBySDKLinks {
    /**
     * 
     * @type {Link}
     * @memberof StreamBySDKLinks
     */
    parent?: Link;
    /**
     * 
     * @type {Link}
     * @memberof StreamBySDKLinks
     */
    self?: Link;
}
/**
 * 
 * @export
 * @interface StreamBySDKLinksMetadata
 */
export interface StreamBySDKLinksMetadata {
    /**
     * 
     * @type {string}
     * @memberof StreamBySDKLinksMetadata
     */
    sdk?: string;
    /**
     * 
     * @type {string}
     * @memberof StreamBySDKLinksMetadata
     */
    version?: string;
    /**
     * 
     * @type {string}
     * @memberof StreamBySDKLinksMetadata
     */
    source?: string;
}
/**
 * 
 * @export
 * @interface StreamLinks
 */
export interface StreamLinks {
    /**
     * 
     * @type {Link}
     * @memberof StreamLinks
     */
    parent?: Link;
    /**
     * 
     * @type {Link}
     * @memberof StreamLinks
     */
    self?: Link;
    /**
     * Links to endpoints that are in the request path.
     * @type {Array<Link>}
     * @memberof StreamLinks
     */
    subseries?: Array<Link>;
}
/**
 * 
 * @export
 * @interface StreamSDKVersion
 */
export interface StreamSDKVersion {
    /**
     * 
     * @type {StreamBySDKLinks}
     * @memberof StreamSDKVersion
     */
    _links?: StreamBySDKLinks;
    /**
     * 
     * @type {Array<StreamSDKVersionData>}
     * @memberof StreamSDKVersion
     */
    sdkVersions?: Array<StreamSDKVersionData>;
}
/**
 * 
 * @export
 * @interface StreamSDKVersionData
 */
export interface StreamSDKVersionData {
    /**
     * The language of the sdk
     * @type {string}
     * @memberof StreamSDKVersionData
     */
    sdk?: string;
    /**
     * The version of the sdk
     * @type {string}
     * @memberof StreamSDKVersionData
     */
    version?: string;
}
/**
 * 
 * @export
 * @interface StreamUsageError
 */
export interface StreamUsageError {
    /**
     * 
     * @type {string}
     * @memberof StreamUsageError
     */
    code?: string;
    /**
     * 
     * @type {string}
     * @memberof StreamUsageError
     */
    message?: string;
}
/**
 * 
 * @export
 * @interface StreamUsageLinks
 */
export interface StreamUsageLinks {
    /**
     * 
     * @type {Link}
     * @memberof StreamUsageLinks
     */
    parent?: Link;
    /**
     * 
     * @type {Link}
     * @memberof StreamUsageLinks
     */
    self?: Link;
    /**
     * The following links that are in the response.
     * @type {Array<Link>}
     * @memberof StreamUsageLinks
     */
    subseries?: Array<Link>;
}
/**
 * 
 * @export
 * @interface StreamUsageMetadata
 */
export interface StreamUsageMetadata {
    /**
     * The language of the sdk
     * @type {string}
     * @memberof StreamUsageMetadata
     */
    sdk?: string;
    /**
     * The version of the SDK
     * @type {string}
     * @memberof StreamUsageMetadata
     */
    version?: string;
    /**
     * 
     * @type {string}
     * @memberof StreamUsageMetadata
     */
    source?: string;
}
/**
 * 
 * @export
 * @interface StreamUsageSeries
 */
export interface StreamUsageSeries {
    /**
     * A key corresponding to a time series data point.
     * @type {number}
     * @memberof StreamUsageSeries
     */
    _0?: number;
    /**
     * A unix epoch time in milliseconds specifying the creation time of this flag.
     * @type {number}
     * @memberof StreamUsageSeries
     */
    time?: number;
}
/**
 * 
 * @export
 * @interface Streams
 */
export interface Streams {
    /**
     * 
     * @type {StreamUsageLinks}
     * @memberof Streams
     */
    _links?: StreamUsageLinks;
}
/**
 * 
 * @export
 * @interface Target
 */
export interface Target {
    /**
     * 
     * @type {Array<string>}
     * @memberof Target
     */
    values?: Array<string>;
    /**
     * 
     * @type {number}
     * @memberof Target
     */
    variation?: number;
}
/**
 * 
 * @export
 * @interface Token
 */
export interface Token {
    /**
     * 
     * @type {Links}
     * @memberof Token
     */
    _links?: Links;
    /**
     * The unique resource id.
     * @type {string}
     * @memberof Token
     */
    _id?: string;
    /**
     * The unique resource id.
     * @type {string}
     * @memberof Token
     */
    ownerId?: string;
    /**
     * The unique resource id.
     * @type {string}
     * @memberof Token
     */
    memberId?: string;
    /**
     * 
     * @type {Member}
     * @memberof Token
     */
    _member?: Member;
    /**
     * A unix epoch time in milliseconds specifying the creation time of this access token.
     * @type {number}
     * @memberof Token
     */
    creationDate?: number;
    /**
     * A unix epoch time in milliseconds specifying the last time this access token was modified.
     * @type {number}
     * @memberof Token
     */
    lastModified?: number;
    /**
     * A unix epoch time in milliseconds specifying the last time this access token was used to authorize access to the LaunchDarkly REST API.
     * @type {number}
     * @memberof Token
     */
    lastUsed?: number;
    /**
     * The last 4 digits of the unique secret key for this access token. If creating or resetting the token, this will be the full token secret.
     * @type {string}
     * @memberof Token
     */
    token?: string;
    /**
     * A human-friendly name for the access token
     * @type {string}
     * @memberof Token
     */
    name?: string;
    /**
     * The name of a built-in role for the token
     * @type {string}
     * @memberof Token
     */
    role?: string;
    /**
     * A list of custom role IDs to use as access limits for the access token
     * @type {Array<string>}
     * @memberof Token
     */
    customRoleIds?: Array<string>;
    /**
     * 
     * @type {Array<Statement>}
     * @memberof Token
     */
    inlineRole?: Array<Statement>;
    /**
     * Whether the token will be a service token https://docs.launchdarkly.com/home/account-security/api-access-tokens#service-tokens
     * @type {boolean}
     * @memberof Token
     */
    serviceToken?: boolean;
    /**
     * The default API version for this token
     * @type {number}
     * @memberof Token
     */
    defaultApiVersion?: number;
}
/**
 * 
 * @export
 * @interface Tokens
 */
export interface Tokens {
    /**
     * 
     * @type {Links}
     * @memberof Tokens
     */
    _links?: Links;
    /**
     * 
     * @type {Array<Token>}
     * @memberof Tokens
     */
    items?: Array<Token>;
}
/**
 * 
 * @export
 * @interface UnboundedSegmentTargetChanges
 */
export interface UnboundedSegmentTargetChanges {
    /**
     * Users to add to this list of targets
     * @type {Array<string>}
     * @memberof UnboundedSegmentTargetChanges
     */
    add?: Array<string>;
    /**
     * Users to remove from this list of targets
     * @type {Array<string>}
     * @memberof UnboundedSegmentTargetChanges
     */
    remove?: Array<string>;
}
/**
 * 
 * @export
 * @interface Usage
 */
export interface Usage {
    /**
     * 
     * @type {UsageLinks}
     * @memberof Usage
     */
    _links?: UsageLinks;
    /**
     * 
     * @type {Array<StreamUsageSeries>}
     * @memberof Usage
     */
    series?: Array<StreamUsageSeries>;
}
/**
 * 
 * @export
 * @interface UsageError
 */
export interface UsageError {
    /**
     * 
     * @type {string}
     * @memberof UsageError
     */
    message?: string;
}
/**
 * 
 * @export
 * @interface UsageLinks
 */
export interface UsageLinks {
    /**
     * 
     * @type {Link}
     * @memberof UsageLinks
     */
    parent?: Link;
    /**
     * 
     * @type {Link}
     * @memberof UsageLinks
     */
    self?: Link;
    /**
     * The following links that are in the response.
     * @type {Array<Link>}
     * @memberof UsageLinks
     */
    subseries?: Array<Link>;
}
/**
 * 
 * @export
 * @interface User
 */
export interface User {
    /**
     * 
     * @type {string}
     * @memberof User
     */
    key?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    secondary?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    ip?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    country?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    email?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    firstName?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    lastName?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    avatar?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    name?: string;
    /**
     * 
     * @type {boolean}
     * @memberof User
     */
    anonymous?: boolean;
    /**
     * 
     * @type {object}
     * @memberof User
     */
    custom?: object;
}
/**
 * 
 * @export
 * @interface UserFlagSetting
 */
export interface UserFlagSetting {
    /**
     * 
     * @type {Links}
     * @memberof UserFlagSetting
     */
    _links?: Links;
    /**
     * The most important attribute in the response. The _value is the current setting for the user. For a boolean feature toggle, this will be true, false, or null if there is no defined fallthrough value.
     * @type {boolean}
     * @memberof UserFlagSetting
     */
    _value?: boolean;
    /**
     * The setting attribute indicates whether you\'ve explicitly targeted this user to receive a particular variation. For example, if you have explicitly turned off a feature toggle for a user, setting will be false. A setting of null means that you haven\'t assigned that user to a specific variation.
     * @type {boolean}
     * @memberof UserFlagSetting
     */
    setting?: boolean;
}
/**
 * 
 * @export
 * @interface UserFlagSettings
 */
export interface UserFlagSettings {
    /**
     * 
     * @type {Links}
     * @memberof UserFlagSettings
     */
    _links?: Links;
    /**
     * 
     * @type {{ [key: string]: UserFlagSetting; }}
     * @memberof UserFlagSettings
     */
    items?: { [key: string]: UserFlagSetting; };
}
/**
 * 
 * @export
 * @interface UserRecord
 */
export interface UserRecord {
    /**
     * 
     * @type {string}
     * @memberof UserRecord
     */
    lastPing?: string;
    /**
     * 
     * @type {string}
     * @memberof UserRecord
     */
    environmentId?: string;
    /**
     * The unique resource id.
     * @type {string}
     * @memberof UserRecord
     */
    ownerId?: string;
    /**
     * 
     * @type {User}
     * @memberof UserRecord
     */
    user?: User;
    /**
     * 
     * @type {string}
     * @memberof UserRecord
     */
    avatar?: string;
}
/**
 * 
 * @export
 * @interface UserSegment
 */
export interface UserSegment {
    /**
     * Unique identifier for the user segment.
     * @type {string}
     * @memberof UserSegment
     */
    key: string;
    /**
     * Name of the user segment.
     * @type {string}
     * @memberof UserSegment
     */
    name: string;
    /**
     * Description of the user segment.
     * @type {string}
     * @memberof UserSegment
     */
    description?: string;
    /**
     * An array of tags for this user segment.
     * @type {Array<string>}
     * @memberof UserSegment
     */
    tags?: Array<string>;
    /**
     * A unix epoch time in milliseconds specifying the creation time of this flag.
     * @type {number}
     * @memberof UserSegment
     */
    creationDate: number;
    /**
     * An array of user keys that are included in this segment.
     * @type {Array<string>}
     * @memberof UserSegment
     */
    included?: Array<string>;
    /**
     * An array of user keys that should not be included in this segment, unless they are also listed in \"included\".
     * @type {Array<string>}
     * @memberof UserSegment
     */
    excluded?: Array<string>;
    /**
     * An array of rules that can cause a user to be included in this segment.
     * @type {Array<UserSegmentRule>}
     * @memberof UserSegment
     */
    rules?: Array<UserSegmentRule>;
    /**
     * Controls whether this segment can support unlimited numbers of users. Requires the beta API and additional setup. Include/exclude lists in this payload are not used in unbounded segments.
     * @type {boolean}
     * @memberof UserSegment
     */
    unbounded?: boolean;
    /**
     * 
     * @type {number}
     * @memberof UserSegment
     */
    version?: number;
    /**
     * 
     * @type {Links}
     * @memberof UserSegment
     */
    _links?: Links;
    /**
     * 
     * @type {Array<FlagListItem>}
     * @memberof UserSegment
     */
    _flags?: Array<FlagListItem>;
}
/**
 * 
 * @export
 * @interface UserSegmentRule
 */
export interface UserSegmentRule {
    /**
     * 
     * @type {Array<Clause>}
     * @memberof UserSegmentRule
     */
    clauses?: Array<Clause>;
    /**
     * 
     * @type {number}
     * @memberof UserSegmentRule
     */
    weight?: number;
    /**
     * 
     * @type {string}
     * @memberof UserSegmentRule
     */
    bucketBy?: string;
}
/**
 * 
 * @export
 * @interface UserSegments
 */
export interface UserSegments {
    /**
     * 
     * @type {Links}
     * @memberof UserSegments
     */
    _links?: Links;
    /**
     * 
     * @type {Array<UserSegment>}
     * @memberof UserSegments
     */
    items?: Array<UserSegment>;
}
/**
 * 
 * @export
 * @interface UserTargetingExpirationForFlag
 */
export interface UserTargetingExpirationForFlag {
    /**
     * Unix epoch time in milliseconds specifying the expiration date
     * @type {number}
     * @memberof UserTargetingExpirationForFlag
     */
    expirationDate?: number;
    /**
     * the ID of the variation that the user is targeted on a flag
     * @type {string}
     * @memberof UserTargetingExpirationForFlag
     */
    variationId?: string;
    /**
     * Unique identifier for the user
     * @type {string}
     * @memberof UserTargetingExpirationForFlag
     */
    userKey?: string;
    /**
     * 
     * @type {string}
     * @memberof UserTargetingExpirationForFlag
     */
    _id?: string;
    /**
     * 
     * @type {UserTargetingExpirationResourceIdForFlag}
     * @memberof UserTargetingExpirationForFlag
     */
    _resourceId?: UserTargetingExpirationResourceIdForFlag;
    /**
     * 
     * @type {Links}
     * @memberof UserTargetingExpirationForFlag
     */
    _links?: Links;
    /**
     * 
     * @type {number}
     * @memberof UserTargetingExpirationForFlag
     */
    _version?: number;
}
/**
 * 
 * @export
 * @interface UserTargetingExpirationForFlags
 */
export interface UserTargetingExpirationForFlags {
    /**
     * 
     * @type {Links}
     * @memberof UserTargetingExpirationForFlags
     */
    _links?: Links;
    /**
     * 
     * @type {Array<UserTargetingExpirationForFlag>}
     * @memberof UserTargetingExpirationForFlags
     */
    items?: Array<UserTargetingExpirationForFlag>;
}
/**
 * 
 * @export
 * @interface UserTargetingExpirationForSegment
 */
export interface UserTargetingExpirationForSegment {
    /**
     * Unix epoch time in milliseconds specifying the expiration date
     * @type {number}
     * @memberof UserTargetingExpirationForSegment
     */
    expirationDate?: number;
    /**
     * either the included or excluded variation that the user is targeted on a segment
     * @type {string}
     * @memberof UserTargetingExpirationForSegment
     */
    targetType?: string;
    /**
     * Unique identifier for the user
     * @type {string}
     * @memberof UserTargetingExpirationForSegment
     */
    userKey?: string;
    /**
     * 
     * @type {string}
     * @memberof UserTargetingExpirationForSegment
     */
    _id?: string;
    /**
     * 
     * @type {UserTargetingExpirationResourceIdForFlag}
     * @memberof UserTargetingExpirationForSegment
     */
    _resourceId?: UserTargetingExpirationResourceIdForFlag;
    /**
     * 
     * @type {Links}
     * @memberof UserTargetingExpirationForSegment
     */
    _links?: Links;
    /**
     * 
     * @type {number}
     * @memberof UserTargetingExpirationForSegment
     */
    _version?: number;
}
/**
 * 
 * @export
 * @interface UserTargetingExpirationOnFlagsForUser
 */
export interface UserTargetingExpirationOnFlagsForUser {
    /**
     * 
     * @type {Links}
     * @memberof UserTargetingExpirationOnFlagsForUser
     */
    _links?: Links;
    /**
     * 
     * @type {Array<UserTargetingExpirationForFlag>}
     * @memberof UserTargetingExpirationOnFlagsForUser
     */
    items?: Array<UserTargetingExpirationForFlag>;
}
/**
 * 
 * @export
 * @interface UserTargetingExpirationResourceIdForFlag
 */
export interface UserTargetingExpirationResourceIdForFlag {
    /**
     * 
     * @type {string}
     * @memberof UserTargetingExpirationResourceIdForFlag
     */
    kind?: string;
    /**
     * 
     * @type {string}
     * @memberof UserTargetingExpirationResourceIdForFlag
     */
    projectKey?: string;
    /**
     * 
     * @type {string}
     * @memberof UserTargetingExpirationResourceIdForFlag
     */
    environmentKey?: string;
    /**
     * 
     * @type {string}
     * @memberof UserTargetingExpirationResourceIdForFlag
     */
    flagKey?: string;
    /**
     * 
     * @type {string}
     * @memberof UserTargetingExpirationResourceIdForFlag
     */
    key?: string;
}
/**
 * 
 * @export
 * @interface Users
 */
export interface Users {
    /**
     * 
     * @type {Links}
     * @memberof Users
     */
    _links?: Links;
    /**
     * 
     * @type {number}
     * @memberof Users
     */
    totalCount?: number;
    /**
     * 
     * @type {Array<UserRecord>}
     * @memberof Users
     */
    items?: Array<UserRecord>;
}
/**
 * 
 * @export
 * @interface Variation
 */
export interface Variation {
    /**
     * 
     * @type {string}
     * @memberof Variation
     */
    _id?: string;
    /**
     * 
     * @type {string}
     * @memberof Variation
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof Variation
     */
    description?: string;
    /**
     * 
     * @type {object}
     * @memberof Variation
     */
    value: object;
}
/**
 * 
 * @export
 * @interface Webhook
 */
export interface Webhook {
    /**
     * 
     * @type {Links}
     * @memberof Webhook
     */
    _links?: Links;
    /**
     * The unique resource id.
     * @type {string}
     * @memberof Webhook
     */
    _id?: string;
    /**
     * The URL of the remote webhook.
     * @type {string}
     * @memberof Webhook
     */
    url?: string;
    /**
     * If defined, the webhooks post request will include a X-LD-Signature header whose value will contain an HMAC SHA256 hex digest of the webhook payload, using the secret as the key.
     * @type {string}
     * @memberof Webhook
     */
    secret?: string;
    /**
     * Whether this webhook is enabled or not.
     * @type {boolean}
     * @memberof Webhook
     */
    on?: boolean;
    /**
     * The name of the webhook.
     * @type {string}
     * @memberof Webhook
     */
    name?: string;
    /**
     * 
     * @type {Array<Statement>}
     * @memberof Webhook
     */
    statements?: Array<Statement>;
    /**
     * Tags assigned to this webhook.
     * @type {Array<string>}
     * @memberof Webhook
     */
    tags?: Array<string>;
}
/**
 * 
 * @export
 * @interface Webhooks
 */
export interface Webhooks {
    /**
     * 
     * @type {Links}
     * @memberof Webhooks
     */
    _links?: Links;
    /**
     * 
     * @type {Array<Webhook>}
     * @memberof Webhooks
     */
    items?: Array<Webhook>;
}
/**
 * 
 * @export
 * @interface WeightedVariation
 */
export interface WeightedVariation {
    /**
     * 
     * @type {number}
     * @memberof WeightedVariation
     */
    variation?: number;
    /**
     * 
     * @type {number}
     * @memberof WeightedVariation
     */
    weight?: number;
}

/**
 * AccessTokensApi - axios parameter creator
 * @export
 */
export const AccessTokensApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Delete an access token by ID.
         * @param {string} tokenId The access token ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteToken: async (tokenId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'tokenId' is not null or undefined
            if (tokenId === null || tokenId === undefined) {
                throw new RequiredError('tokenId','Required parameter tokenId was null or undefined when calling deleteToken.');
            }
            const localVarPath = `/tokens/{tokenId}`
                .replace(`{${"tokenId"}}`, encodeURIComponent(String(tokenId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a single access token by ID.
         * @param {string} tokenId The access token ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getToken: async (tokenId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'tokenId' is not null or undefined
            if (tokenId === null || tokenId === undefined) {
                throw new RequiredError('tokenId','Required parameter tokenId was null or undefined when calling getToken.');
            }
            const localVarPath = `/tokens/{tokenId}`
                .replace(`{${"tokenId"}}`, encodeURIComponent(String(tokenId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns a list of tokens in the account.
         * @param {boolean} [showAll] If set to true, and the authentication access token has the \&quot;Admin\&quot; role, personal access tokens for all members will be retrieved.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTokens: async (showAll?: boolean, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/tokens`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (showAll !== undefined) {
                localVarQueryParameter['showAll'] = showAll;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Modify an access token by ID.
         * @param {string} tokenId The access token ID.
         * @param {Array<PatchOperation>} patchDelta Requires a JSON Patch representation of the desired changes to the project. \&#39;http://jsonpatch.com/\&#39;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchToken: async (tokenId: string, patchDelta: Array<PatchOperation>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'tokenId' is not null or undefined
            if (tokenId === null || tokenId === undefined) {
                throw new RequiredError('tokenId','Required parameter tokenId was null or undefined when calling patchToken.');
            }
            // verify required parameter 'patchDelta' is not null or undefined
            if (patchDelta === null || patchDelta === undefined) {
                throw new RequiredError('patchDelta','Required parameter patchDelta was null or undefined when calling patchToken.');
            }
            const localVarPath = `/tokens/{tokenId}`
                .replace(`{${"tokenId"}}`, encodeURIComponent(String(tokenId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof patchDelta !== "string") && configuration.isJsonMime(localVarRequestOptions.headers['Content-Type']);
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(patchDelta !== undefined ? patchDelta : {}) : (patchDelta || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a new token.
         * @param {InlineObject10} tokenBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postToken: async (tokenBody: InlineObject10, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'tokenBody' is not null or undefined
            if (tokenBody === null || tokenBody === undefined) {
                throw new RequiredError('tokenBody','Required parameter tokenBody was null or undefined when calling postToken.');
            }
            const localVarPath = `/tokens`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof tokenBody !== "string") && configuration.isJsonMime(localVarRequestOptions.headers['Content-Type']);
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(tokenBody !== undefined ? tokenBody : {}) : (tokenBody || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Reset an access token\'s secret key with an optional expiry time for the old key.
         * @param {string} tokenId The access token ID.
         * @param {number} [expiry] An expiration time for the old token key, expressed as a Unix epoch time in milliseconds. By default, the token will expire immediately.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetToken: async (tokenId: string, expiry?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'tokenId' is not null or undefined
            if (tokenId === null || tokenId === undefined) {
                throw new RequiredError('tokenId','Required parameter tokenId was null or undefined when calling resetToken.');
            }
            const localVarPath = `/tokens/{tokenId}/reset`
                .replace(`{${"tokenId"}}`, encodeURIComponent(String(tokenId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (expiry !== undefined) {
                localVarQueryParameter['expiry'] = expiry;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AccessTokensApi - functional programming interface
 * @export
 */
export const AccessTokensApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Delete an access token by ID.
         * @param {string} tokenId The access token ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteToken(tokenId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await AccessTokensApiAxiosParamCreator(configuration).deleteToken(tokenId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get a single access token by ID.
         * @param {string} tokenId The access token ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getToken(tokenId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Token>> {
            const localVarAxiosArgs = await AccessTokensApiAxiosParamCreator(configuration).getToken(tokenId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Returns a list of tokens in the account.
         * @param {boolean} [showAll] If set to true, and the authentication access token has the \&quot;Admin\&quot; role, personal access tokens for all members will be retrieved.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTokens(showAll?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Tokens>> {
            const localVarAxiosArgs = await AccessTokensApiAxiosParamCreator(configuration).getTokens(showAll, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Modify an access token by ID.
         * @param {string} tokenId The access token ID.
         * @param {Array<PatchOperation>} patchDelta Requires a JSON Patch representation of the desired changes to the project. \&#39;http://jsonpatch.com/\&#39;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchToken(tokenId: string, patchDelta: Array<PatchOperation>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Token>> {
            const localVarAxiosArgs = await AccessTokensApiAxiosParamCreator(configuration).patchToken(tokenId, patchDelta, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Create a new token.
         * @param {InlineObject10} tokenBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postToken(tokenBody: InlineObject10, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Token>> {
            const localVarAxiosArgs = await AccessTokensApiAxiosParamCreator(configuration).postToken(tokenBody, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Reset an access token\'s secret key with an optional expiry time for the old key.
         * @param {string} tokenId The access token ID.
         * @param {number} [expiry] An expiration time for the old token key, expressed as a Unix epoch time in milliseconds. By default, the token will expire immediately.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resetToken(tokenId: string, expiry?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Token>> {
            const localVarAxiosArgs = await AccessTokensApiAxiosParamCreator(configuration).resetToken(tokenId, expiry, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * AccessTokensApi - factory interface
 * @export
 */
export const AccessTokensApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Delete an access token by ID.
         * @param {string} tokenId The access token ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteToken(tokenId: string, options?: any): AxiosPromise<void> {
            return AccessTokensApiFp(configuration).deleteToken(tokenId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a single access token by ID.
         * @param {string} tokenId The access token ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getToken(tokenId: string, options?: any): AxiosPromise<Token> {
            return AccessTokensApiFp(configuration).getToken(tokenId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns a list of tokens in the account.
         * @param {boolean} [showAll] If set to true, and the authentication access token has the \&quot;Admin\&quot; role, personal access tokens for all members will be retrieved.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTokens(showAll?: boolean, options?: any): AxiosPromise<Tokens> {
            return AccessTokensApiFp(configuration).getTokens(showAll, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Modify an access token by ID.
         * @param {string} tokenId The access token ID.
         * @param {Array<PatchOperation>} patchDelta Requires a JSON Patch representation of the desired changes to the project. \&#39;http://jsonpatch.com/\&#39;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchToken(tokenId: string, patchDelta: Array<PatchOperation>, options?: any): AxiosPromise<Token> {
            return AccessTokensApiFp(configuration).patchToken(tokenId, patchDelta, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a new token.
         * @param {InlineObject10} tokenBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postToken(tokenBody: InlineObject10, options?: any): AxiosPromise<Token> {
            return AccessTokensApiFp(configuration).postToken(tokenBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Reset an access token\'s secret key with an optional expiry time for the old key.
         * @param {string} tokenId The access token ID.
         * @param {number} [expiry] An expiration time for the old token key, expressed as a Unix epoch time in milliseconds. By default, the token will expire immediately.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetToken(tokenId: string, expiry?: number, options?: any): AxiosPromise<Token> {
            return AccessTokensApiFp(configuration).resetToken(tokenId, expiry, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AccessTokensApi - object-oriented interface
 * @export
 * @class AccessTokensApi
 * @extends {BaseAPI}
 */
export class AccessTokensApi extends BaseAPI {
    /**
     * 
     * @summary Delete an access token by ID.
     * @param {string} tokenId The access token ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessTokensApi
     */
    public deleteToken(tokenId: string, options?: any) {
        return AccessTokensApiFp(this.configuration).deleteToken(tokenId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a single access token by ID.
     * @param {string} tokenId The access token ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessTokensApi
     */
    public getToken(tokenId: string, options?: any) {
        return AccessTokensApiFp(this.configuration).getToken(tokenId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns a list of tokens in the account.
     * @param {boolean} [showAll] If set to true, and the authentication access token has the \&quot;Admin\&quot; role, personal access tokens for all members will be retrieved.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessTokensApi
     */
    public getTokens(showAll?: boolean, options?: any) {
        return AccessTokensApiFp(this.configuration).getTokens(showAll, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Modify an access token by ID.
     * @param {string} tokenId The access token ID.
     * @param {Array<PatchOperation>} patchDelta Requires a JSON Patch representation of the desired changes to the project. \&#39;http://jsonpatch.com/\&#39;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessTokensApi
     */
    public patchToken(tokenId: string, patchDelta: Array<PatchOperation>, options?: any) {
        return AccessTokensApiFp(this.configuration).patchToken(tokenId, patchDelta, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a new token.
     * @param {InlineObject10} tokenBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessTokensApi
     */
    public postToken(tokenBody: InlineObject10, options?: any) {
        return AccessTokensApiFp(this.configuration).postToken(tokenBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Reset an access token\'s secret key with an optional expiry time for the old key.
     * @param {string} tokenId The access token ID.
     * @param {number} [expiry] An expiration time for the old token key, expressed as a Unix epoch time in milliseconds. By default, the token will expire immediately.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessTokensApi
     */
    public resetToken(tokenId: string, expiry?: number, options?: any) {
        return AccessTokensApiFp(this.configuration).resetToken(tokenId, expiry, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * AuditLogApi - axios parameter creator
 * @export
 */
export const AuditLogApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get a list of all audit log entries. The query parameters allow you to restrict the returned results by date ranges, resource specifiers, or a full-text search query.
         * @param {number} [before] A timestamp filter, expressed as a Unix epoch time in milliseconds. All entries returned will have before this timestamp.
         * @param {number} [after] A timestamp filter, expressed as a Unix epoch time in milliseconds. All entries returned will have occurred after this timestamp.
         * @param {string} [q] Text to search for. You can search for the full or partial name of the resource involved or full or partial email address of the member who made the change.
         * @param {number} [limit] A limit on the number of audit log entries to be returned, between 1 and 20.
         * @param {string} [spec] A resource specifier, allowing you to filter audit log listings by resource.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAuditLogEntries: async (before?: number, after?: number, q?: string, limit?: number, spec?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/auditlog`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (before !== undefined) {
                localVarQueryParameter['before'] = before;
            }

            if (after !== undefined) {
                localVarQueryParameter['after'] = after;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (spec !== undefined) {
                localVarQueryParameter['spec'] = spec;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Use this endpoint to fetch a single audit log entry by its resouce ID.
         * @param {string} resourceId The resource ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAuditLogEntry: async (resourceId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'resourceId' is not null or undefined
            if (resourceId === null || resourceId === undefined) {
                throw new RequiredError('resourceId','Required parameter resourceId was null or undefined when calling getAuditLogEntry.');
            }
            const localVarPath = `/auditlog/{resourceId}`
                .replace(`{${"resourceId"}}`, encodeURIComponent(String(resourceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuditLogApi - functional programming interface
 * @export
 */
export const AuditLogApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get a list of all audit log entries. The query parameters allow you to restrict the returned results by date ranges, resource specifiers, or a full-text search query.
         * @param {number} [before] A timestamp filter, expressed as a Unix epoch time in milliseconds. All entries returned will have before this timestamp.
         * @param {number} [after] A timestamp filter, expressed as a Unix epoch time in milliseconds. All entries returned will have occurred after this timestamp.
         * @param {string} [q] Text to search for. You can search for the full or partial name of the resource involved or full or partial email address of the member who made the change.
         * @param {number} [limit] A limit on the number of audit log entries to be returned, between 1 and 20.
         * @param {string} [spec] A resource specifier, allowing you to filter audit log listings by resource.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAuditLogEntries(before?: number, after?: number, q?: string, limit?: number, spec?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuditLogEntries>> {
            const localVarAxiosArgs = await AuditLogApiAxiosParamCreator(configuration).getAuditLogEntries(before, after, q, limit, spec, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Use this endpoint to fetch a single audit log entry by its resouce ID.
         * @param {string} resourceId The resource ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAuditLogEntry(resourceId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuditLogEntry>> {
            const localVarAxiosArgs = await AuditLogApiAxiosParamCreator(configuration).getAuditLogEntry(resourceId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * AuditLogApi - factory interface
 * @export
 */
export const AuditLogApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Get a list of all audit log entries. The query parameters allow you to restrict the returned results by date ranges, resource specifiers, or a full-text search query.
         * @param {number} [before] A timestamp filter, expressed as a Unix epoch time in milliseconds. All entries returned will have before this timestamp.
         * @param {number} [after] A timestamp filter, expressed as a Unix epoch time in milliseconds. All entries returned will have occurred after this timestamp.
         * @param {string} [q] Text to search for. You can search for the full or partial name of the resource involved or full or partial email address of the member who made the change.
         * @param {number} [limit] A limit on the number of audit log entries to be returned, between 1 and 20.
         * @param {string} [spec] A resource specifier, allowing you to filter audit log listings by resource.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAuditLogEntries(before?: number, after?: number, q?: string, limit?: number, spec?: string, options?: any): AxiosPromise<AuditLogEntries> {
            return AuditLogApiFp(configuration).getAuditLogEntries(before, after, q, limit, spec, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Use this endpoint to fetch a single audit log entry by its resouce ID.
         * @param {string} resourceId The resource ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAuditLogEntry(resourceId: string, options?: any): AxiosPromise<AuditLogEntry> {
            return AuditLogApiFp(configuration).getAuditLogEntry(resourceId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuditLogApi - object-oriented interface
 * @export
 * @class AuditLogApi
 * @extends {BaseAPI}
 */
export class AuditLogApi extends BaseAPI {
    /**
     * 
     * @summary Get a list of all audit log entries. The query parameters allow you to restrict the returned results by date ranges, resource specifiers, or a full-text search query.
     * @param {number} [before] A timestamp filter, expressed as a Unix epoch time in milliseconds. All entries returned will have before this timestamp.
     * @param {number} [after] A timestamp filter, expressed as a Unix epoch time in milliseconds. All entries returned will have occurred after this timestamp.
     * @param {string} [q] Text to search for. You can search for the full or partial name of the resource involved or full or partial email address of the member who made the change.
     * @param {number} [limit] A limit on the number of audit log entries to be returned, between 1 and 20.
     * @param {string} [spec] A resource specifier, allowing you to filter audit log listings by resource.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuditLogApi
     */
    public getAuditLogEntries(before?: number, after?: number, q?: string, limit?: number, spec?: string, options?: any) {
        return AuditLogApiFp(this.configuration).getAuditLogEntries(before, after, q, limit, spec, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Use this endpoint to fetch a single audit log entry by its resouce ID.
     * @param {string} resourceId The resource ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuditLogApi
     */
    public getAuditLogEntry(resourceId: string, options?: any) {
        return AuditLogApiFp(this.configuration).getAuditLogEntry(resourceId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CustomRolesApi - axios parameter creator
 * @export
 */
export const CustomRolesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Delete a custom role by key.
         * @param {string} customRoleKey The custom role key.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCustomRole: async (customRoleKey: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'customRoleKey' is not null or undefined
            if (customRoleKey === null || customRoleKey === undefined) {
                throw new RequiredError('customRoleKey','Required parameter customRoleKey was null or undefined when calling deleteCustomRole.');
            }
            const localVarPath = `/roles/{customRoleKey}`
                .replace(`{${"customRoleKey"}}`, encodeURIComponent(String(customRoleKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get one custom role by key.
         * @param {string} customRoleKey The custom role key.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomRole: async (customRoleKey: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'customRoleKey' is not null or undefined
            if (customRoleKey === null || customRoleKey === undefined) {
                throw new RequiredError('customRoleKey','Required parameter customRoleKey was null or undefined when calling getCustomRole.');
            }
            const localVarPath = `/roles/{customRoleKey}`
                .replace(`{${"customRoleKey"}}`, encodeURIComponent(String(customRoleKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Return a complete list of custom roles.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomRoles: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/roles`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Modify a custom role by key.
         * @param {string} customRoleKey The custom role key.
         * @param {Array<PatchOperation>} patchDelta Requires a JSON Patch representation of the desired changes to the project. \&#39;http://jsonpatch.com/\&#39;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchCustomRole: async (customRoleKey: string, patchDelta: Array<PatchOperation>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'customRoleKey' is not null or undefined
            if (customRoleKey === null || customRoleKey === undefined) {
                throw new RequiredError('customRoleKey','Required parameter customRoleKey was null or undefined when calling patchCustomRole.');
            }
            // verify required parameter 'patchDelta' is not null or undefined
            if (patchDelta === null || patchDelta === undefined) {
                throw new RequiredError('patchDelta','Required parameter patchDelta was null or undefined when calling patchCustomRole.');
            }
            const localVarPath = `/roles/{customRoleKey}`
                .replace(`{${"customRoleKey"}}`, encodeURIComponent(String(customRoleKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof patchDelta !== "string") && configuration.isJsonMime(localVarRequestOptions.headers['Content-Type']);
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(patchDelta !== undefined ? patchDelta : {}) : (patchDelta || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a new custom role.
         * @param {InlineObject8} customRoleBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCustomRole: async (customRoleBody: InlineObject8, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'customRoleBody' is not null or undefined
            if (customRoleBody === null || customRoleBody === undefined) {
                throw new RequiredError('customRoleBody','Required parameter customRoleBody was null or undefined when calling postCustomRole.');
            }
            const localVarPath = `/roles`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof customRoleBody !== "string") && configuration.isJsonMime(localVarRequestOptions.headers['Content-Type']);
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(customRoleBody !== undefined ? customRoleBody : {}) : (customRoleBody || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CustomRolesApi - functional programming interface
 * @export
 */
export const CustomRolesApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Delete a custom role by key.
         * @param {string} customRoleKey The custom role key.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteCustomRole(customRoleKey: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await CustomRolesApiAxiosParamCreator(configuration).deleteCustomRole(customRoleKey, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get one custom role by key.
         * @param {string} customRoleKey The custom role key.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCustomRole(customRoleKey: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomRole>> {
            const localVarAxiosArgs = await CustomRolesApiAxiosParamCreator(configuration).getCustomRole(customRoleKey, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Return a complete list of custom roles.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCustomRoles(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomRoles>> {
            const localVarAxiosArgs = await CustomRolesApiAxiosParamCreator(configuration).getCustomRoles(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Modify a custom role by key.
         * @param {string} customRoleKey The custom role key.
         * @param {Array<PatchOperation>} patchDelta Requires a JSON Patch representation of the desired changes to the project. \&#39;http://jsonpatch.com/\&#39;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchCustomRole(customRoleKey: string, patchDelta: Array<PatchOperation>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomRole>> {
            const localVarAxiosArgs = await CustomRolesApiAxiosParamCreator(configuration).patchCustomRole(customRoleKey, patchDelta, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Create a new custom role.
         * @param {InlineObject8} customRoleBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postCustomRole(customRoleBody: InlineObject8, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomRole>> {
            const localVarAxiosArgs = await CustomRolesApiAxiosParamCreator(configuration).postCustomRole(customRoleBody, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * CustomRolesApi - factory interface
 * @export
 */
export const CustomRolesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Delete a custom role by key.
         * @param {string} customRoleKey The custom role key.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCustomRole(customRoleKey: string, options?: any): AxiosPromise<void> {
            return CustomRolesApiFp(configuration).deleteCustomRole(customRoleKey, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get one custom role by key.
         * @param {string} customRoleKey The custom role key.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomRole(customRoleKey: string, options?: any): AxiosPromise<CustomRole> {
            return CustomRolesApiFp(configuration).getCustomRole(customRoleKey, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Return a complete list of custom roles.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomRoles(options?: any): AxiosPromise<CustomRoles> {
            return CustomRolesApiFp(configuration).getCustomRoles(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Modify a custom role by key.
         * @param {string} customRoleKey The custom role key.
         * @param {Array<PatchOperation>} patchDelta Requires a JSON Patch representation of the desired changes to the project. \&#39;http://jsonpatch.com/\&#39;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchCustomRole(customRoleKey: string, patchDelta: Array<PatchOperation>, options?: any): AxiosPromise<CustomRole> {
            return CustomRolesApiFp(configuration).patchCustomRole(customRoleKey, patchDelta, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a new custom role.
         * @param {InlineObject8} customRoleBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCustomRole(customRoleBody: InlineObject8, options?: any): AxiosPromise<CustomRole> {
            return CustomRolesApiFp(configuration).postCustomRole(customRoleBody, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CustomRolesApi - object-oriented interface
 * @export
 * @class CustomRolesApi
 * @extends {BaseAPI}
 */
export class CustomRolesApi extends BaseAPI {
    /**
     * 
     * @summary Delete a custom role by key.
     * @param {string} customRoleKey The custom role key.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomRolesApi
     */
    public deleteCustomRole(customRoleKey: string, options?: any) {
        return CustomRolesApiFp(this.configuration).deleteCustomRole(customRoleKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get one custom role by key.
     * @param {string} customRoleKey The custom role key.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomRolesApi
     */
    public getCustomRole(customRoleKey: string, options?: any) {
        return CustomRolesApiFp(this.configuration).getCustomRole(customRoleKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Return a complete list of custom roles.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomRolesApi
     */
    public getCustomRoles(options?: any) {
        return CustomRolesApiFp(this.configuration).getCustomRoles(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Modify a custom role by key.
     * @param {string} customRoleKey The custom role key.
     * @param {Array<PatchOperation>} patchDelta Requires a JSON Patch representation of the desired changes to the project. \&#39;http://jsonpatch.com/\&#39;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomRolesApi
     */
    public patchCustomRole(customRoleKey: string, patchDelta: Array<PatchOperation>, options?: any) {
        return CustomRolesApiFp(this.configuration).patchCustomRole(customRoleKey, patchDelta, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a new custom role.
     * @param {InlineObject8} customRoleBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomRolesApi
     */
    public postCustomRole(customRoleBody: InlineObject8, options?: any) {
        return CustomRolesApiFp(this.configuration).postCustomRole(customRoleBody, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CustomerMetricsApi - axios parameter creator
 * @export
 */
export const CustomerMetricsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get events usage by event id and the feature flag key.
         * @param {string} envId The environment id for the flag evaluations in question.
         * @param {string} flagKey The key of the flag we want metrics for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEvaluations: async (envId: string, flagKey: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'envId' is not null or undefined
            if (envId === null || envId === undefined) {
                throw new RequiredError('envId','Required parameter envId was null or undefined when calling getEvaluations.');
            }
            // verify required parameter 'flagKey' is not null or undefined
            if (flagKey === null || flagKey === undefined) {
                throw new RequiredError('flagKey','Required parameter flagKey was null or undefined when calling getEvaluations.');
            }
            const localVarPath = `/usage/evaluations/{envId}/{flagKey}`
                .replace(`{${"envId"}}`, encodeURIComponent(String(envId)))
                .replace(`{${"flagKey"}}`, encodeURIComponent(String(flagKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get events usage by event type.
         * @param {string} type The type of event we would like to track.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEvent: async (type: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'type' is not null or undefined
            if (type === null || type === undefined) {
                throw new RequiredError('type','Required parameter type was null or undefined when calling getEvent.');
            }
            const localVarPath = `/usage/events/{type}`
                .replace(`{${"type"}}`, encodeURIComponent(String(type)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get events usage endpoints.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEvents: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/usage/events`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get monthly active user data.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMAU: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/usage/mau`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get monthly active user data by category.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMAUByCategory: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/usage/mau/bycategory`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a stream endpoint and return timeseries data.
         * @param {string} source The source of where the stream comes from.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStream: async (source: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'source' is not null or undefined
            if (source === null || source === undefined) {
                throw new RequiredError('source','Required parameter source was null or undefined when calling getStream.');
            }
            const localVarPath = `/usage/streams/{source}`
                .replace(`{${"source"}}`, encodeURIComponent(String(source)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a stream timeseries data by source show sdk version metadata.
         * @param {string} source The source of where the stream comes from.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStreamBySDK: async (source: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'source' is not null or undefined
            if (source === null || source === undefined) {
                throw new RequiredError('source','Required parameter source was null or undefined when calling getStreamBySDK.');
            }
            const localVarPath = `/usage/streams/{source}/bysdkversion`
                .replace(`{${"source"}}`, encodeURIComponent(String(source)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a stream timeseries data by source and show all sdk version associated.
         * @param {string} source The source of where the stream comes from.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStreamSDKVersion: async (source: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'source' is not null or undefined
            if (source === null || source === undefined) {
                throw new RequiredError('source','Required parameter source was null or undefined when calling getStreamSDKVersion.');
            }
            const localVarPath = `/usage/streams/{source}/sdkversions`
                .replace(`{${"source"}}`, encodeURIComponent(String(source)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns a list of all streams.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStreams: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/usage/streams`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns of the usage endpoints available.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsage: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/usage`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CustomerMetricsApi - functional programming interface
 * @export
 */
export const CustomerMetricsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get events usage by event id and the feature flag key.
         * @param {string} envId The environment id for the flag evaluations in question.
         * @param {string} flagKey The key of the flag we want metrics for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEvaluations(envId: string, flagKey: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StreamSDKVersion>> {
            const localVarAxiosArgs = await CustomerMetricsApiAxiosParamCreator(configuration).getEvaluations(envId, flagKey, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get events usage by event type.
         * @param {string} type The type of event we would like to track.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEvent(type: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StreamSDKVersion>> {
            const localVarAxiosArgs = await CustomerMetricsApiAxiosParamCreator(configuration).getEvent(type, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get events usage endpoints.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEvents(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Events>> {
            const localVarAxiosArgs = await CustomerMetricsApiAxiosParamCreator(configuration).getEvents(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get monthly active user data.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMAU(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MAU>> {
            const localVarAxiosArgs = await CustomerMetricsApiAxiosParamCreator(configuration).getMAU(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get monthly active user data by category.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMAUByCategory(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MAUbyCategory>> {
            const localVarAxiosArgs = await CustomerMetricsApiAxiosParamCreator(configuration).getMAUByCategory(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get a stream endpoint and return timeseries data.
         * @param {string} source The source of where the stream comes from.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStream(source: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Stream>> {
            const localVarAxiosArgs = await CustomerMetricsApiAxiosParamCreator(configuration).getStream(source, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get a stream timeseries data by source show sdk version metadata.
         * @param {string} source The source of where the stream comes from.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStreamBySDK(source: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StreamBySDK>> {
            const localVarAxiosArgs = await CustomerMetricsApiAxiosParamCreator(configuration).getStreamBySDK(source, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get a stream timeseries data by source and show all sdk version associated.
         * @param {string} source The source of where the stream comes from.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStreamSDKVersion(source: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StreamSDKVersion>> {
            const localVarAxiosArgs = await CustomerMetricsApiAxiosParamCreator(configuration).getStreamSDKVersion(source, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Returns a list of all streams.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStreams(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Streams>> {
            const localVarAxiosArgs = await CustomerMetricsApiAxiosParamCreator(configuration).getStreams(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Returns of the usage endpoints available.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUsage(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Usage>> {
            const localVarAxiosArgs = await CustomerMetricsApiAxiosParamCreator(configuration).getUsage(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * CustomerMetricsApi - factory interface
 * @export
 */
export const CustomerMetricsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Get events usage by event id and the feature flag key.
         * @param {string} envId The environment id for the flag evaluations in question.
         * @param {string} flagKey The key of the flag we want metrics for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEvaluations(envId: string, flagKey: string, options?: any): AxiosPromise<StreamSDKVersion> {
            return CustomerMetricsApiFp(configuration).getEvaluations(envId, flagKey, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get events usage by event type.
         * @param {string} type The type of event we would like to track.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEvent(type: string, options?: any): AxiosPromise<StreamSDKVersion> {
            return CustomerMetricsApiFp(configuration).getEvent(type, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get events usage endpoints.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEvents(options?: any): AxiosPromise<Events> {
            return CustomerMetricsApiFp(configuration).getEvents(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get monthly active user data.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMAU(options?: any): AxiosPromise<MAU> {
            return CustomerMetricsApiFp(configuration).getMAU(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get monthly active user data by category.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMAUByCategory(options?: any): AxiosPromise<MAUbyCategory> {
            return CustomerMetricsApiFp(configuration).getMAUByCategory(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a stream endpoint and return timeseries data.
         * @param {string} source The source of where the stream comes from.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStream(source: string, options?: any): AxiosPromise<Stream> {
            return CustomerMetricsApiFp(configuration).getStream(source, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a stream timeseries data by source show sdk version metadata.
         * @param {string} source The source of where the stream comes from.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStreamBySDK(source: string, options?: any): AxiosPromise<StreamBySDK> {
            return CustomerMetricsApiFp(configuration).getStreamBySDK(source, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a stream timeseries data by source and show all sdk version associated.
         * @param {string} source The source of where the stream comes from.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStreamSDKVersion(source: string, options?: any): AxiosPromise<StreamSDKVersion> {
            return CustomerMetricsApiFp(configuration).getStreamSDKVersion(source, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns a list of all streams.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStreams(options?: any): AxiosPromise<Streams> {
            return CustomerMetricsApiFp(configuration).getStreams(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns of the usage endpoints available.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsage(options?: any): AxiosPromise<Usage> {
            return CustomerMetricsApiFp(configuration).getUsage(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CustomerMetricsApi - object-oriented interface
 * @export
 * @class CustomerMetricsApi
 * @extends {BaseAPI}
 */
export class CustomerMetricsApi extends BaseAPI {
    /**
     * 
     * @summary Get events usage by event id and the feature flag key.
     * @param {string} envId The environment id for the flag evaluations in question.
     * @param {string} flagKey The key of the flag we want metrics for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerMetricsApi
     */
    public getEvaluations(envId: string, flagKey: string, options?: any) {
        return CustomerMetricsApiFp(this.configuration).getEvaluations(envId, flagKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get events usage by event type.
     * @param {string} type The type of event we would like to track.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerMetricsApi
     */
    public getEvent(type: string, options?: any) {
        return CustomerMetricsApiFp(this.configuration).getEvent(type, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get events usage endpoints.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerMetricsApi
     */
    public getEvents(options?: any) {
        return CustomerMetricsApiFp(this.configuration).getEvents(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get monthly active user data.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerMetricsApi
     */
    public getMAU(options?: any) {
        return CustomerMetricsApiFp(this.configuration).getMAU(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get monthly active user data by category.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerMetricsApi
     */
    public getMAUByCategory(options?: any) {
        return CustomerMetricsApiFp(this.configuration).getMAUByCategory(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a stream endpoint and return timeseries data.
     * @param {string} source The source of where the stream comes from.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerMetricsApi
     */
    public getStream(source: string, options?: any) {
        return CustomerMetricsApiFp(this.configuration).getStream(source, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a stream timeseries data by source show sdk version metadata.
     * @param {string} source The source of where the stream comes from.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerMetricsApi
     */
    public getStreamBySDK(source: string, options?: any) {
        return CustomerMetricsApiFp(this.configuration).getStreamBySDK(source, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a stream timeseries data by source and show all sdk version associated.
     * @param {string} source The source of where the stream comes from.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerMetricsApi
     */
    public getStreamSDKVersion(source: string, options?: any) {
        return CustomerMetricsApiFp(this.configuration).getStreamSDKVersion(source, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns a list of all streams.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerMetricsApi
     */
    public getStreams(options?: any) {
        return CustomerMetricsApiFp(this.configuration).getStreams(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns of the usage endpoints available.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerMetricsApi
     */
    public getUsage(options?: any) {
        return CustomerMetricsApiFp(this.configuration).getUsage(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DataExportDestinationsApi - axios parameter creator
 * @export
 */
export const DataExportDestinationsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get a single data export destination by ID
         * @param {string} projectKey The project key, used to tie the flags together under one project so they can be managed together.
         * @param {string} environmentKey The environment key, used to tie together flag configuration and users under one environment so they can be managed together.
         * @param {string} destinationId The data export destination ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDestination: async (projectKey: string, environmentKey: string, destinationId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            if (projectKey === null || projectKey === undefined) {
                throw new RequiredError('projectKey','Required parameter projectKey was null or undefined when calling deleteDestination.');
            }
            // verify required parameter 'environmentKey' is not null or undefined
            if (environmentKey === null || environmentKey === undefined) {
                throw new RequiredError('environmentKey','Required parameter environmentKey was null or undefined when calling deleteDestination.');
            }
            // verify required parameter 'destinationId' is not null or undefined
            if (destinationId === null || destinationId === undefined) {
                throw new RequiredError('destinationId','Required parameter destinationId was null or undefined when calling deleteDestination.');
            }
            const localVarPath = `/destinations/{projectKey}/{environmentKey}/{destinationId}`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)))
                .replace(`{${"environmentKey"}}`, encodeURIComponent(String(environmentKey)))
                .replace(`{${"destinationId"}}`, encodeURIComponent(String(destinationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a single data export destination by ID
         * @param {string} projectKey The project key, used to tie the flags together under one project so they can be managed together.
         * @param {string} environmentKey The environment key, used to tie together flag configuration and users under one environment so they can be managed together.
         * @param {string} destinationId The data export destination ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDestination: async (projectKey: string, environmentKey: string, destinationId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            if (projectKey === null || projectKey === undefined) {
                throw new RequiredError('projectKey','Required parameter projectKey was null or undefined when calling getDestination.');
            }
            // verify required parameter 'environmentKey' is not null or undefined
            if (environmentKey === null || environmentKey === undefined) {
                throw new RequiredError('environmentKey','Required parameter environmentKey was null or undefined when calling getDestination.');
            }
            // verify required parameter 'destinationId' is not null or undefined
            if (destinationId === null || destinationId === undefined) {
                throw new RequiredError('destinationId','Required parameter destinationId was null or undefined when calling getDestination.');
            }
            const localVarPath = `/destinations/{projectKey}/{environmentKey}/{destinationId}`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)))
                .replace(`{${"environmentKey"}}`, encodeURIComponent(String(environmentKey)))
                .replace(`{${"destinationId"}}`, encodeURIComponent(String(destinationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns a list of all data export destinations.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDestinations: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/destinations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Perform a partial update to a data export destination.
         * @param {string} projectKey The project key, used to tie the flags together under one project so they can be managed together.
         * @param {string} environmentKey The environment key, used to tie together flag configuration and users under one environment so they can be managed together.
         * @param {string} destinationId The data export destination ID.
         * @param {Array<PatchOperation>} patchOnly Requires a JSON Patch representation of the desired changes to the project. \&#39;http://jsonpatch.com/\&#39; Feature flag patches also support JSON Merge Patch format. \&#39;https://tools.ietf.org/html/rfc7386\&#39; The addition of comments is also supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchDestination: async (projectKey: string, environmentKey: string, destinationId: string, patchOnly: Array<PatchOperation>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            if (projectKey === null || projectKey === undefined) {
                throw new RequiredError('projectKey','Required parameter projectKey was null or undefined when calling patchDestination.');
            }
            // verify required parameter 'environmentKey' is not null or undefined
            if (environmentKey === null || environmentKey === undefined) {
                throw new RequiredError('environmentKey','Required parameter environmentKey was null or undefined when calling patchDestination.');
            }
            // verify required parameter 'destinationId' is not null or undefined
            if (destinationId === null || destinationId === undefined) {
                throw new RequiredError('destinationId','Required parameter destinationId was null or undefined when calling patchDestination.');
            }
            // verify required parameter 'patchOnly' is not null or undefined
            if (patchOnly === null || patchOnly === undefined) {
                throw new RequiredError('patchOnly','Required parameter patchOnly was null or undefined when calling patchDestination.');
            }
            const localVarPath = `/destinations/{projectKey}/{environmentKey}/{destinationId}`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)))
                .replace(`{${"environmentKey"}}`, encodeURIComponent(String(environmentKey)))
                .replace(`{${"destinationId"}}`, encodeURIComponent(String(destinationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof patchOnly !== "string") && configuration.isJsonMime(localVarRequestOptions.headers['Content-Type']);
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(patchOnly !== undefined ? patchOnly : {}) : (patchOnly || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a new data export destination
         * @param {string} projectKey The project key, used to tie the flags together under one project so they can be managed together.
         * @param {string} environmentKey The environment key, used to tie together flag configuration and users under one environment so they can be managed together.
         * @param {InlineObject9} destinationBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postDestination: async (projectKey: string, environmentKey: string, destinationBody: InlineObject9, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            if (projectKey === null || projectKey === undefined) {
                throw new RequiredError('projectKey','Required parameter projectKey was null or undefined when calling postDestination.');
            }
            // verify required parameter 'environmentKey' is not null or undefined
            if (environmentKey === null || environmentKey === undefined) {
                throw new RequiredError('environmentKey','Required parameter environmentKey was null or undefined when calling postDestination.');
            }
            // verify required parameter 'destinationBody' is not null or undefined
            if (destinationBody === null || destinationBody === undefined) {
                throw new RequiredError('destinationBody','Required parameter destinationBody was null or undefined when calling postDestination.');
            }
            const localVarPath = `/destinations/{projectKey}/{environmentKey}`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)))
                .replace(`{${"environmentKey"}}`, encodeURIComponent(String(environmentKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof destinationBody !== "string") && configuration.isJsonMime(localVarRequestOptions.headers['Content-Type']);
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(destinationBody !== undefined ? destinationBody : {}) : (destinationBody || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DataExportDestinationsApi - functional programming interface
 * @export
 */
export const DataExportDestinationsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get a single data export destination by ID
         * @param {string} projectKey The project key, used to tie the flags together under one project so they can be managed together.
         * @param {string} environmentKey The environment key, used to tie together flag configuration and users under one environment so they can be managed together.
         * @param {string} destinationId The data export destination ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteDestination(projectKey: string, environmentKey: string, destinationId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await DataExportDestinationsApiAxiosParamCreator(configuration).deleteDestination(projectKey, environmentKey, destinationId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get a single data export destination by ID
         * @param {string} projectKey The project key, used to tie the flags together under one project so they can be managed together.
         * @param {string} environmentKey The environment key, used to tie together flag configuration and users under one environment so they can be managed together.
         * @param {string} destinationId The data export destination ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDestination(projectKey: string, environmentKey: string, destinationId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Destination>> {
            const localVarAxiosArgs = await DataExportDestinationsApiAxiosParamCreator(configuration).getDestination(projectKey, environmentKey, destinationId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Returns a list of all data export destinations.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDestinations(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Destinations>> {
            const localVarAxiosArgs = await DataExportDestinationsApiAxiosParamCreator(configuration).getDestinations(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Perform a partial update to a data export destination.
         * @param {string} projectKey The project key, used to tie the flags together under one project so they can be managed together.
         * @param {string} environmentKey The environment key, used to tie together flag configuration and users under one environment so they can be managed together.
         * @param {string} destinationId The data export destination ID.
         * @param {Array<PatchOperation>} patchOnly Requires a JSON Patch representation of the desired changes to the project. \&#39;http://jsonpatch.com/\&#39; Feature flag patches also support JSON Merge Patch format. \&#39;https://tools.ietf.org/html/rfc7386\&#39; The addition of comments is also supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchDestination(projectKey: string, environmentKey: string, destinationId: string, patchOnly: Array<PatchOperation>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Destination>> {
            const localVarAxiosArgs = await DataExportDestinationsApiAxiosParamCreator(configuration).patchDestination(projectKey, environmentKey, destinationId, patchOnly, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Create a new data export destination
         * @param {string} projectKey The project key, used to tie the flags together under one project so they can be managed together.
         * @param {string} environmentKey The environment key, used to tie together flag configuration and users under one environment so they can be managed together.
         * @param {InlineObject9} destinationBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postDestination(projectKey: string, environmentKey: string, destinationBody: InlineObject9, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Destination>> {
            const localVarAxiosArgs = await DataExportDestinationsApiAxiosParamCreator(configuration).postDestination(projectKey, environmentKey, destinationBody, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * DataExportDestinationsApi - factory interface
 * @export
 */
export const DataExportDestinationsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Get a single data export destination by ID
         * @param {string} projectKey The project key, used to tie the flags together under one project so they can be managed together.
         * @param {string} environmentKey The environment key, used to tie together flag configuration and users under one environment so they can be managed together.
         * @param {string} destinationId The data export destination ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDestination(projectKey: string, environmentKey: string, destinationId: string, options?: any): AxiosPromise<void> {
            return DataExportDestinationsApiFp(configuration).deleteDestination(projectKey, environmentKey, destinationId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a single data export destination by ID
         * @param {string} projectKey The project key, used to tie the flags together under one project so they can be managed together.
         * @param {string} environmentKey The environment key, used to tie together flag configuration and users under one environment so they can be managed together.
         * @param {string} destinationId The data export destination ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDestination(projectKey: string, environmentKey: string, destinationId: string, options?: any): AxiosPromise<Destination> {
            return DataExportDestinationsApiFp(configuration).getDestination(projectKey, environmentKey, destinationId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns a list of all data export destinations.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDestinations(options?: any): AxiosPromise<Destinations> {
            return DataExportDestinationsApiFp(configuration).getDestinations(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Perform a partial update to a data export destination.
         * @param {string} projectKey The project key, used to tie the flags together under one project so they can be managed together.
         * @param {string} environmentKey The environment key, used to tie together flag configuration and users under one environment so they can be managed together.
         * @param {string} destinationId The data export destination ID.
         * @param {Array<PatchOperation>} patchOnly Requires a JSON Patch representation of the desired changes to the project. \&#39;http://jsonpatch.com/\&#39; Feature flag patches also support JSON Merge Patch format. \&#39;https://tools.ietf.org/html/rfc7386\&#39; The addition of comments is also supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchDestination(projectKey: string, environmentKey: string, destinationId: string, patchOnly: Array<PatchOperation>, options?: any): AxiosPromise<Destination> {
            return DataExportDestinationsApiFp(configuration).patchDestination(projectKey, environmentKey, destinationId, patchOnly, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a new data export destination
         * @param {string} projectKey The project key, used to tie the flags together under one project so they can be managed together.
         * @param {string} environmentKey The environment key, used to tie together flag configuration and users under one environment so they can be managed together.
         * @param {InlineObject9} destinationBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postDestination(projectKey: string, environmentKey: string, destinationBody: InlineObject9, options?: any): AxiosPromise<Destination> {
            return DataExportDestinationsApiFp(configuration).postDestination(projectKey, environmentKey, destinationBody, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DataExportDestinationsApi - object-oriented interface
 * @export
 * @class DataExportDestinationsApi
 * @extends {BaseAPI}
 */
export class DataExportDestinationsApi extends BaseAPI {
    /**
     * 
     * @summary Get a single data export destination by ID
     * @param {string} projectKey The project key, used to tie the flags together under one project so they can be managed together.
     * @param {string} environmentKey The environment key, used to tie together flag configuration and users under one environment so they can be managed together.
     * @param {string} destinationId The data export destination ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataExportDestinationsApi
     */
    public deleteDestination(projectKey: string, environmentKey: string, destinationId: string, options?: any) {
        return DataExportDestinationsApiFp(this.configuration).deleteDestination(projectKey, environmentKey, destinationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a single data export destination by ID
     * @param {string} projectKey The project key, used to tie the flags together under one project so they can be managed together.
     * @param {string} environmentKey The environment key, used to tie together flag configuration and users under one environment so they can be managed together.
     * @param {string} destinationId The data export destination ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataExportDestinationsApi
     */
    public getDestination(projectKey: string, environmentKey: string, destinationId: string, options?: any) {
        return DataExportDestinationsApiFp(this.configuration).getDestination(projectKey, environmentKey, destinationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns a list of all data export destinations.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataExportDestinationsApi
     */
    public getDestinations(options?: any) {
        return DataExportDestinationsApiFp(this.configuration).getDestinations(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Perform a partial update to a data export destination.
     * @param {string} projectKey The project key, used to tie the flags together under one project so they can be managed together.
     * @param {string} environmentKey The environment key, used to tie together flag configuration and users under one environment so they can be managed together.
     * @param {string} destinationId The data export destination ID.
     * @param {Array<PatchOperation>} patchOnly Requires a JSON Patch representation of the desired changes to the project. \&#39;http://jsonpatch.com/\&#39; Feature flag patches also support JSON Merge Patch format. \&#39;https://tools.ietf.org/html/rfc7386\&#39; The addition of comments is also supported.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataExportDestinationsApi
     */
    public patchDestination(projectKey: string, environmentKey: string, destinationId: string, patchOnly: Array<PatchOperation>, options?: any) {
        return DataExportDestinationsApiFp(this.configuration).patchDestination(projectKey, environmentKey, destinationId, patchOnly, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a new data export destination
     * @param {string} projectKey The project key, used to tie the flags together under one project so they can be managed together.
     * @param {string} environmentKey The environment key, used to tie together flag configuration and users under one environment so they can be managed together.
     * @param {InlineObject9} destinationBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataExportDestinationsApi
     */
    public postDestination(projectKey: string, environmentKey: string, destinationBody: InlineObject9, options?: any) {
        return DataExportDestinationsApiFp(this.configuration).postDestination(projectKey, environmentKey, destinationBody, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * EnvironmentsApi - axios parameter creator
 * @export
 */
export const EnvironmentsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Delete an environment in a specific project.
         * @param {string} projectKey The project key, used to tie the flags together under one project so they can be managed together.
         * @param {string} environmentKey The environment key, used to tie together flag configuration and users under one environment so they can be managed together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEnvironment: async (projectKey: string, environmentKey: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            if (projectKey === null || projectKey === undefined) {
                throw new RequiredError('projectKey','Required parameter projectKey was null or undefined when calling deleteEnvironment.');
            }
            // verify required parameter 'environmentKey' is not null or undefined
            if (environmentKey === null || environmentKey === undefined) {
                throw new RequiredError('environmentKey','Required parameter environmentKey was null or undefined when calling deleteEnvironment.');
            }
            const localVarPath = `/projects/{projectKey}/environments/{environmentKey}`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)))
                .replace(`{${"environmentKey"}}`, encodeURIComponent(String(environmentKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get an environment given a project and key.
         * @param {string} projectKey The project key, used to tie the flags together under one project so they can be managed together.
         * @param {string} environmentKey The environment key, used to tie together flag configuration and users under one environment so they can be managed together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEnvironment: async (projectKey: string, environmentKey: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            if (projectKey === null || projectKey === undefined) {
                throw new RequiredError('projectKey','Required parameter projectKey was null or undefined when calling getEnvironment.');
            }
            // verify required parameter 'environmentKey' is not null or undefined
            if (environmentKey === null || environmentKey === undefined) {
                throw new RequiredError('environmentKey','Required parameter environmentKey was null or undefined when calling getEnvironment.');
            }
            const localVarPath = `/projects/{projectKey}/environments/{environmentKey}`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)))
                .replace(`{${"environmentKey"}}`, encodeURIComponent(String(environmentKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Modify an environment by ID.
         * @param {string} projectKey The project key, used to tie the flags together under one project so they can be managed together.
         * @param {string} environmentKey The environment key, used to tie together flag configuration and users under one environment so they can be managed together.
         * @param {Array<PatchOperation>} patchDelta Requires a JSON Patch representation of the desired changes to the project. \&#39;http://jsonpatch.com/\&#39;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchEnvironment: async (projectKey: string, environmentKey: string, patchDelta: Array<PatchOperation>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            if (projectKey === null || projectKey === undefined) {
                throw new RequiredError('projectKey','Required parameter projectKey was null or undefined when calling patchEnvironment.');
            }
            // verify required parameter 'environmentKey' is not null or undefined
            if (environmentKey === null || environmentKey === undefined) {
                throw new RequiredError('environmentKey','Required parameter environmentKey was null or undefined when calling patchEnvironment.');
            }
            // verify required parameter 'patchDelta' is not null or undefined
            if (patchDelta === null || patchDelta === undefined) {
                throw new RequiredError('patchDelta','Required parameter patchDelta was null or undefined when calling patchEnvironment.');
            }
            const localVarPath = `/projects/{projectKey}/environments/{environmentKey}`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)))
                .replace(`{${"environmentKey"}}`, encodeURIComponent(String(environmentKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof patchDelta !== "string") && configuration.isJsonMime(localVarRequestOptions.headers['Content-Type']);
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(patchDelta !== undefined ? patchDelta : {}) : (patchDelta || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a new environment in a specified project with a given name, key, and swatch color.
         * @param {string} projectKey The project key, used to tie the flags together under one project so they can be managed together.
         * @param {EnvironmentPost} environmentBody New environment.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postEnvironment: async (projectKey: string, environmentBody: EnvironmentPost, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            if (projectKey === null || projectKey === undefined) {
                throw new RequiredError('projectKey','Required parameter projectKey was null or undefined when calling postEnvironment.');
            }
            // verify required parameter 'environmentBody' is not null or undefined
            if (environmentBody === null || environmentBody === undefined) {
                throw new RequiredError('environmentBody','Required parameter environmentBody was null or undefined when calling postEnvironment.');
            }
            const localVarPath = `/projects/{projectKey}/environments`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof environmentBody !== "string") && configuration.isJsonMime(localVarRequestOptions.headers['Content-Type']);
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(environmentBody !== undefined ? environmentBody : {}) : (environmentBody || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Reset an environment\'s mobile key. The optional expiry for the old key is deprecated for this endpoint, so the old key will always expire immediately.
         * @param {string} projectKey The project key, used to tie the flags together under one project so they can be managed together.
         * @param {string} environmentKey The environment key, used to tie together flag configuration and users under one environment so they can be managed together.
         * @param {number} [expiry] The expiry parameter is deprecated for this endpoint, so the old mobile key will always expire immediately. This parameter will be removed in an upcoming major API client version.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetEnvironmentMobileKey: async (projectKey: string, environmentKey: string, expiry?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            if (projectKey === null || projectKey === undefined) {
                throw new RequiredError('projectKey','Required parameter projectKey was null or undefined when calling resetEnvironmentMobileKey.');
            }
            // verify required parameter 'environmentKey' is not null or undefined
            if (environmentKey === null || environmentKey === undefined) {
                throw new RequiredError('environmentKey','Required parameter environmentKey was null or undefined when calling resetEnvironmentMobileKey.');
            }
            const localVarPath = `/projects/{projectKey}/environments/{environmentKey}/mobileKey`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)))
                .replace(`{${"environmentKey"}}`, encodeURIComponent(String(environmentKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (expiry !== undefined) {
                localVarQueryParameter['expiry'] = expiry;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Reset an environment\'s SDK key with an optional expiry time for the old key.
         * @param {string} projectKey The project key, used to tie the flags together under one project so they can be managed together.
         * @param {string} environmentKey The environment key, used to tie together flag configuration and users under one environment so they can be managed together.
         * @param {number} [expiry] An expiration time for the old environment SDK key, expressed as a Unix epoch time in milliseconds. By default, the key will expire immediately.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetEnvironmentSDKKey: async (projectKey: string, environmentKey: string, expiry?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            if (projectKey === null || projectKey === undefined) {
                throw new RequiredError('projectKey','Required parameter projectKey was null or undefined when calling resetEnvironmentSDKKey.');
            }
            // verify required parameter 'environmentKey' is not null or undefined
            if (environmentKey === null || environmentKey === undefined) {
                throw new RequiredError('environmentKey','Required parameter environmentKey was null or undefined when calling resetEnvironmentSDKKey.');
            }
            const localVarPath = `/projects/{projectKey}/environments/{environmentKey}/apiKey`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)))
                .replace(`{${"environmentKey"}}`, encodeURIComponent(String(environmentKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (expiry !== undefined) {
                localVarQueryParameter['expiry'] = expiry;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EnvironmentsApi - functional programming interface
 * @export
 */
export const EnvironmentsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Delete an environment in a specific project.
         * @param {string} projectKey The project key, used to tie the flags together under one project so they can be managed together.
         * @param {string} environmentKey The environment key, used to tie together flag configuration and users under one environment so they can be managed together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteEnvironment(projectKey: string, environmentKey: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await EnvironmentsApiAxiosParamCreator(configuration).deleteEnvironment(projectKey, environmentKey, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get an environment given a project and key.
         * @param {string} projectKey The project key, used to tie the flags together under one project so they can be managed together.
         * @param {string} environmentKey The environment key, used to tie together flag configuration and users under one environment so they can be managed together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEnvironment(projectKey: string, environmentKey: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Environment>> {
            const localVarAxiosArgs = await EnvironmentsApiAxiosParamCreator(configuration).getEnvironment(projectKey, environmentKey, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Modify an environment by ID.
         * @param {string} projectKey The project key, used to tie the flags together under one project so they can be managed together.
         * @param {string} environmentKey The environment key, used to tie together flag configuration and users under one environment so they can be managed together.
         * @param {Array<PatchOperation>} patchDelta Requires a JSON Patch representation of the desired changes to the project. \&#39;http://jsonpatch.com/\&#39;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchEnvironment(projectKey: string, environmentKey: string, patchDelta: Array<PatchOperation>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Environment>> {
            const localVarAxiosArgs = await EnvironmentsApiAxiosParamCreator(configuration).patchEnvironment(projectKey, environmentKey, patchDelta, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Create a new environment in a specified project with a given name, key, and swatch color.
         * @param {string} projectKey The project key, used to tie the flags together under one project so they can be managed together.
         * @param {EnvironmentPost} environmentBody New environment.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postEnvironment(projectKey: string, environmentBody: EnvironmentPost, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Environment>> {
            const localVarAxiosArgs = await EnvironmentsApiAxiosParamCreator(configuration).postEnvironment(projectKey, environmentBody, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Reset an environment\'s mobile key. The optional expiry for the old key is deprecated for this endpoint, so the old key will always expire immediately.
         * @param {string} projectKey The project key, used to tie the flags together under one project so they can be managed together.
         * @param {string} environmentKey The environment key, used to tie together flag configuration and users under one environment so they can be managed together.
         * @param {number} [expiry] The expiry parameter is deprecated for this endpoint, so the old mobile key will always expire immediately. This parameter will be removed in an upcoming major API client version.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resetEnvironmentMobileKey(projectKey: string, environmentKey: string, expiry?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Environment>> {
            const localVarAxiosArgs = await EnvironmentsApiAxiosParamCreator(configuration).resetEnvironmentMobileKey(projectKey, environmentKey, expiry, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Reset an environment\'s SDK key with an optional expiry time for the old key.
         * @param {string} projectKey The project key, used to tie the flags together under one project so they can be managed together.
         * @param {string} environmentKey The environment key, used to tie together flag configuration and users under one environment so they can be managed together.
         * @param {number} [expiry] An expiration time for the old environment SDK key, expressed as a Unix epoch time in milliseconds. By default, the key will expire immediately.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resetEnvironmentSDKKey(projectKey: string, environmentKey: string, expiry?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Environment>> {
            const localVarAxiosArgs = await EnvironmentsApiAxiosParamCreator(configuration).resetEnvironmentSDKKey(projectKey, environmentKey, expiry, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * EnvironmentsApi - factory interface
 * @export
 */
export const EnvironmentsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Delete an environment in a specific project.
         * @param {string} projectKey The project key, used to tie the flags together under one project so they can be managed together.
         * @param {string} environmentKey The environment key, used to tie together flag configuration and users under one environment so they can be managed together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEnvironment(projectKey: string, environmentKey: string, options?: any): AxiosPromise<void> {
            return EnvironmentsApiFp(configuration).deleteEnvironment(projectKey, environmentKey, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get an environment given a project and key.
         * @param {string} projectKey The project key, used to tie the flags together under one project so they can be managed together.
         * @param {string} environmentKey The environment key, used to tie together flag configuration and users under one environment so they can be managed together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEnvironment(projectKey: string, environmentKey: string, options?: any): AxiosPromise<Environment> {
            return EnvironmentsApiFp(configuration).getEnvironment(projectKey, environmentKey, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Modify an environment by ID.
         * @param {string} projectKey The project key, used to tie the flags together under one project so they can be managed together.
         * @param {string} environmentKey The environment key, used to tie together flag configuration and users under one environment so they can be managed together.
         * @param {Array<PatchOperation>} patchDelta Requires a JSON Patch representation of the desired changes to the project. \&#39;http://jsonpatch.com/\&#39;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchEnvironment(projectKey: string, environmentKey: string, patchDelta: Array<PatchOperation>, options?: any): AxiosPromise<Environment> {
            return EnvironmentsApiFp(configuration).patchEnvironment(projectKey, environmentKey, patchDelta, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a new environment in a specified project with a given name, key, and swatch color.
         * @param {string} projectKey The project key, used to tie the flags together under one project so they can be managed together.
         * @param {EnvironmentPost} environmentBody New environment.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postEnvironment(projectKey: string, environmentBody: EnvironmentPost, options?: any): AxiosPromise<Environment> {
            return EnvironmentsApiFp(configuration).postEnvironment(projectKey, environmentBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Reset an environment\'s mobile key. The optional expiry for the old key is deprecated for this endpoint, so the old key will always expire immediately.
         * @param {string} projectKey The project key, used to tie the flags together under one project so they can be managed together.
         * @param {string} environmentKey The environment key, used to tie together flag configuration and users under one environment so they can be managed together.
         * @param {number} [expiry] The expiry parameter is deprecated for this endpoint, so the old mobile key will always expire immediately. This parameter will be removed in an upcoming major API client version.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetEnvironmentMobileKey(projectKey: string, environmentKey: string, expiry?: number, options?: any): AxiosPromise<Environment> {
            return EnvironmentsApiFp(configuration).resetEnvironmentMobileKey(projectKey, environmentKey, expiry, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Reset an environment\'s SDK key with an optional expiry time for the old key.
         * @param {string} projectKey The project key, used to tie the flags together under one project so they can be managed together.
         * @param {string} environmentKey The environment key, used to tie together flag configuration and users under one environment so they can be managed together.
         * @param {number} [expiry] An expiration time for the old environment SDK key, expressed as a Unix epoch time in milliseconds. By default, the key will expire immediately.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetEnvironmentSDKKey(projectKey: string, environmentKey: string, expiry?: number, options?: any): AxiosPromise<Environment> {
            return EnvironmentsApiFp(configuration).resetEnvironmentSDKKey(projectKey, environmentKey, expiry, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EnvironmentsApi - object-oriented interface
 * @export
 * @class EnvironmentsApi
 * @extends {BaseAPI}
 */
export class EnvironmentsApi extends BaseAPI {
    /**
     * 
     * @summary Delete an environment in a specific project.
     * @param {string} projectKey The project key, used to tie the flags together under one project so they can be managed together.
     * @param {string} environmentKey The environment key, used to tie together flag configuration and users under one environment so they can be managed together.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentsApi
     */
    public deleteEnvironment(projectKey: string, environmentKey: string, options?: any) {
        return EnvironmentsApiFp(this.configuration).deleteEnvironment(projectKey, environmentKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get an environment given a project and key.
     * @param {string} projectKey The project key, used to tie the flags together under one project so they can be managed together.
     * @param {string} environmentKey The environment key, used to tie together flag configuration and users under one environment so they can be managed together.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentsApi
     */
    public getEnvironment(projectKey: string, environmentKey: string, options?: any) {
        return EnvironmentsApiFp(this.configuration).getEnvironment(projectKey, environmentKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Modify an environment by ID.
     * @param {string} projectKey The project key, used to tie the flags together under one project so they can be managed together.
     * @param {string} environmentKey The environment key, used to tie together flag configuration and users under one environment so they can be managed together.
     * @param {Array<PatchOperation>} patchDelta Requires a JSON Patch representation of the desired changes to the project. \&#39;http://jsonpatch.com/\&#39;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentsApi
     */
    public patchEnvironment(projectKey: string, environmentKey: string, patchDelta: Array<PatchOperation>, options?: any) {
        return EnvironmentsApiFp(this.configuration).patchEnvironment(projectKey, environmentKey, patchDelta, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a new environment in a specified project with a given name, key, and swatch color.
     * @param {string} projectKey The project key, used to tie the flags together under one project so they can be managed together.
     * @param {EnvironmentPost} environmentBody New environment.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentsApi
     */
    public postEnvironment(projectKey: string, environmentBody: EnvironmentPost, options?: any) {
        return EnvironmentsApiFp(this.configuration).postEnvironment(projectKey, environmentBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Reset an environment\'s mobile key. The optional expiry for the old key is deprecated for this endpoint, so the old key will always expire immediately.
     * @param {string} projectKey The project key, used to tie the flags together under one project so they can be managed together.
     * @param {string} environmentKey The environment key, used to tie together flag configuration and users under one environment so they can be managed together.
     * @param {number} [expiry] The expiry parameter is deprecated for this endpoint, so the old mobile key will always expire immediately. This parameter will be removed in an upcoming major API client version.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentsApi
     */
    public resetEnvironmentMobileKey(projectKey: string, environmentKey: string, expiry?: number, options?: any) {
        return EnvironmentsApiFp(this.configuration).resetEnvironmentMobileKey(projectKey, environmentKey, expiry, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Reset an environment\'s SDK key with an optional expiry time for the old key.
     * @param {string} projectKey The project key, used to tie the flags together under one project so they can be managed together.
     * @param {string} environmentKey The environment key, used to tie together flag configuration and users under one environment so they can be managed together.
     * @param {number} [expiry] An expiration time for the old environment SDK key, expressed as a Unix epoch time in milliseconds. By default, the key will expire immediately.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentsApi
     */
    public resetEnvironmentSDKKey(projectKey: string, environmentKey: string, expiry?: number, options?: any) {
        return EnvironmentsApiFp(this.configuration).resetEnvironmentSDKKey(projectKey, environmentKey, expiry, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * FeatureFlagsApi - axios parameter creator
 * @export
 */
export const FeatureFlagsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Copies the feature flag configuration from one environment to the same feature flag in another environment.
         * @param {string} projectKey The project key, used to tie the flags together under one project so they can be managed together.
         * @param {string} featureFlagKey The feature flag\&#39;s key. The key identifies the flag in your code.
         * @param {InlineObject3} featureFlagCopyBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        copyFeatureFlag: async (projectKey: string, featureFlagKey: string, featureFlagCopyBody: InlineObject3, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            if (projectKey === null || projectKey === undefined) {
                throw new RequiredError('projectKey','Required parameter projectKey was null or undefined when calling copyFeatureFlag.');
            }
            // verify required parameter 'featureFlagKey' is not null or undefined
            if (featureFlagKey === null || featureFlagKey === undefined) {
                throw new RequiredError('featureFlagKey','Required parameter featureFlagKey was null or undefined when calling copyFeatureFlag.');
            }
            // verify required parameter 'featureFlagCopyBody' is not null or undefined
            if (featureFlagCopyBody === null || featureFlagCopyBody === undefined) {
                throw new RequiredError('featureFlagCopyBody','Required parameter featureFlagCopyBody was null or undefined when calling copyFeatureFlag.');
            }
            const localVarPath = `/flags/{projectKey}/{featureFlagKey}/copy`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)))
                .replace(`{${"featureFlagKey"}}`, encodeURIComponent(String(featureFlagKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof featureFlagCopyBody !== "string") && configuration.isJsonMime(localVarRequestOptions.headers['Content-Type']);
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(featureFlagCopyBody !== undefined ? featureFlagCopyBody : {}) : (featureFlagCopyBody || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a feature flag in all environments. Be careful-- only delete feature flags that are no longer being used by your application.
         * @param {string} projectKey The project key, used to tie the flags together under one project so they can be managed together.
         * @param {string} featureFlagKey The feature flag\&#39;s key. The key identifies the flag in your code.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFeatureFlag: async (projectKey: string, featureFlagKey: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            if (projectKey === null || projectKey === undefined) {
                throw new RequiredError('projectKey','Required parameter projectKey was null or undefined when calling deleteFeatureFlag.');
            }
            // verify required parameter 'featureFlagKey' is not null or undefined
            if (featureFlagKey === null || featureFlagKey === undefined) {
                throw new RequiredError('featureFlagKey','Required parameter featureFlagKey was null or undefined when calling deleteFeatureFlag.');
            }
            const localVarPath = `/flags/{projectKey}/{featureFlagKey}`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)))
                .replace(`{${"featureFlagKey"}}`, encodeURIComponent(String(featureFlagKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get expiring user targets for feature flag
         * @param {string} projectKey The project key, used to tie the flags together under one project so they can be managed together.
         * @param {string} environmentKey The environment key, used to tie together flag configuration and users under one environment so they can be managed together.
         * @param {string} featureFlagKey The feature flag\&#39;s key. The key identifies the flag in your code.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExpiringUserTargets: async (projectKey: string, environmentKey: string, featureFlagKey: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            if (projectKey === null || projectKey === undefined) {
                throw new RequiredError('projectKey','Required parameter projectKey was null or undefined when calling getExpiringUserTargets.');
            }
            // verify required parameter 'environmentKey' is not null or undefined
            if (environmentKey === null || environmentKey === undefined) {
                throw new RequiredError('environmentKey','Required parameter environmentKey was null or undefined when calling getExpiringUserTargets.');
            }
            // verify required parameter 'featureFlagKey' is not null or undefined
            if (featureFlagKey === null || featureFlagKey === undefined) {
                throw new RequiredError('featureFlagKey','Required parameter featureFlagKey was null or undefined when calling getExpiringUserTargets.');
            }
            const localVarPath = `/flags/{projectKey}/{featureFlagKey}/expiring-user-targets/{environmentKey}`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)))
                .replace(`{${"environmentKey"}}`, encodeURIComponent(String(environmentKey)))
                .replace(`{${"featureFlagKey"}}`, encodeURIComponent(String(featureFlagKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a single feature flag by key.
         * @param {string} projectKey The project key, used to tie the flags together under one project so they can be managed together.
         * @param {string} featureFlagKey The feature flag\&#39;s key. The key identifies the flag in your code.
         * @param {Array<string>} [env] By default, each feature will include configurations for each environment. You can filter environments with the env query parameter. For example, setting env&#x3D;[\&quot;production\&quot;] will restrict the returned configurations to just your production environment.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFeatureFlag: async (projectKey: string, featureFlagKey: string, env?: Array<string>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            if (projectKey === null || projectKey === undefined) {
                throw new RequiredError('projectKey','Required parameter projectKey was null or undefined when calling getFeatureFlag.');
            }
            // verify required parameter 'featureFlagKey' is not null or undefined
            if (featureFlagKey === null || featureFlagKey === undefined) {
                throw new RequiredError('featureFlagKey','Required parameter featureFlagKey was null or undefined when calling getFeatureFlag.');
            }
            const localVarPath = `/flags/{projectKey}/{featureFlagKey}`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)))
                .replace(`{${"featureFlagKey"}}`, encodeURIComponent(String(featureFlagKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (env) {
                localVarQueryParameter['env'] = env;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the status for a particular feature flag.
         * @param {string} projectKey The project key, used to tie the flags together under one project so they can be managed together.
         * @param {string} environmentKey The environment key, used to tie together flag configuration and users under one environment so they can be managed together.
         * @param {string} featureFlagKey The feature flag\&#39;s key. The key identifies the flag in your code.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFeatureFlagStatus: async (projectKey: string, environmentKey: string, featureFlagKey: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            if (projectKey === null || projectKey === undefined) {
                throw new RequiredError('projectKey','Required parameter projectKey was null or undefined when calling getFeatureFlagStatus.');
            }
            // verify required parameter 'environmentKey' is not null or undefined
            if (environmentKey === null || environmentKey === undefined) {
                throw new RequiredError('environmentKey','Required parameter environmentKey was null or undefined when calling getFeatureFlagStatus.');
            }
            // verify required parameter 'featureFlagKey' is not null or undefined
            if (featureFlagKey === null || featureFlagKey === undefined) {
                throw new RequiredError('featureFlagKey','Required parameter featureFlagKey was null or undefined when calling getFeatureFlagStatus.');
            }
            const localVarPath = `/flag-statuses/{projectKey}/{environmentKey}/{featureFlagKey}`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)))
                .replace(`{${"environmentKey"}}`, encodeURIComponent(String(environmentKey)))
                .replace(`{${"featureFlagKey"}}`, encodeURIComponent(String(featureFlagKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the status for a particular feature flag across environments
         * @param {string} projectKey The project key, used to tie the flags together under one project so they can be managed together.
         * @param {string} featureFlagKey The feature flag\&#39;s key. The key identifies the flag in your code.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFeatureFlagStatusAcrossEnvironments: async (projectKey: string, featureFlagKey: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            if (projectKey === null || projectKey === undefined) {
                throw new RequiredError('projectKey','Required parameter projectKey was null or undefined when calling getFeatureFlagStatusAcrossEnvironments.');
            }
            // verify required parameter 'featureFlagKey' is not null or undefined
            if (featureFlagKey === null || featureFlagKey === undefined) {
                throw new RequiredError('featureFlagKey','Required parameter featureFlagKey was null or undefined when calling getFeatureFlagStatusAcrossEnvironments.');
            }
            const localVarPath = `/flag-status/{projectKey}/{featureFlagKey}`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)))
                .replace(`{${"featureFlagKey"}}`, encodeURIComponent(String(featureFlagKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a list of statuses for all feature flags. The status includes the last time the feature flag was requested, as well as the state of the flag.
         * @param {string} projectKey The project key, used to tie the flags together under one project so they can be managed together.
         * @param {string} environmentKey The environment key, used to tie together flag configuration and users under one environment so they can be managed together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFeatureFlagStatuses: async (projectKey: string, environmentKey: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            if (projectKey === null || projectKey === undefined) {
                throw new RequiredError('projectKey','Required parameter projectKey was null or undefined when calling getFeatureFlagStatuses.');
            }
            // verify required parameter 'environmentKey' is not null or undefined
            if (environmentKey === null || environmentKey === undefined) {
                throw new RequiredError('environmentKey','Required parameter environmentKey was null or undefined when calling getFeatureFlagStatuses.');
            }
            const localVarPath = `/flag-statuses/{projectKey}/{environmentKey}`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)))
                .replace(`{${"environmentKey"}}`, encodeURIComponent(String(environmentKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a list of all features in the given project.
         * @param {string} projectKey The project key, used to tie the flags together under one project so they can be managed together.
         * @param {Array<string>} [env] By default, each feature will include configurations for each environment. You can filter environments with the env query parameter. For example, setting env&#x3D;[\&quot;production\&quot;] will restrict the returned configurations to just your production environment.
         * @param {boolean} [summary] By default in api version &gt;&#x3D; 1, flags will _not_ include their list of prerequisites, targets or rules.  Set summary&#x3D;0 to include these fields for each flag returned.
         * @param {boolean} [archived] When set to 1, only archived flags will be included in the list of flags returned.  By default, archived flags are not included in the list of flags.
         * @param {number} [limit] The number of objects to return. Defaults to -1, which returns everything.
         * @param {number} [offset] Where to start in the list. This is for use with pagination. For example, an offset of 10 would skip the first 10 items and then return the next limit items.
         * @param {string} [filter] A comma-separated list of filters. Each filter is of the form field:value.
         * @param {string} [sort] A comma-separated list of fields to sort by. A field prefixed by a - will be sorted in descending order.
         * @param {string} [tag] Filter by tag. A tag can be used to group flags across projects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFeatureFlags: async (projectKey: string, env?: Array<string>, summary?: boolean, archived?: boolean, limit?: number, offset?: number, filter?: string, sort?: string, tag?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            if (projectKey === null || projectKey === undefined) {
                throw new RequiredError('projectKey','Required parameter projectKey was null or undefined when calling getFeatureFlags.');
            }
            const localVarPath = `/flags/{projectKey}`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (env) {
                localVarQueryParameter['env'] = env;
            }

            if (summary !== undefined) {
                localVarQueryParameter['summary'] = summary;
            }

            if (archived !== undefined) {
                localVarQueryParameter['archived'] = archived;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (tag !== undefined) {
                localVarQueryParameter['tag'] = tag;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update, add, or delete expiring user targets on feature flag
         * @param {string} projectKey The project key, used to tie the flags together under one project so they can be managed together.
         * @param {string} environmentKey The environment key, used to tie together flag configuration and users under one environment so they can be managed together.
         * @param {string} featureFlagKey The feature flag\&#39;s key. The key identifies the flag in your code.
         * @param {object} semanticPatchWithComment Requires a Semantic Patch representation of the desired changes to the resource. \&#39;https://apidocs.launchdarkly.com/reference#updates-via-semantic-patches\&#39;. The addition of comments is also supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchExpiringUserTargets: async (projectKey: string, environmentKey: string, featureFlagKey: string, semanticPatchWithComment: object, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            if (projectKey === null || projectKey === undefined) {
                throw new RequiredError('projectKey','Required parameter projectKey was null or undefined when calling patchExpiringUserTargets.');
            }
            // verify required parameter 'environmentKey' is not null or undefined
            if (environmentKey === null || environmentKey === undefined) {
                throw new RequiredError('environmentKey','Required parameter environmentKey was null or undefined when calling patchExpiringUserTargets.');
            }
            // verify required parameter 'featureFlagKey' is not null or undefined
            if (featureFlagKey === null || featureFlagKey === undefined) {
                throw new RequiredError('featureFlagKey','Required parameter featureFlagKey was null or undefined when calling patchExpiringUserTargets.');
            }
            // verify required parameter 'semanticPatchWithComment' is not null or undefined
            if (semanticPatchWithComment === null || semanticPatchWithComment === undefined) {
                throw new RequiredError('semanticPatchWithComment','Required parameter semanticPatchWithComment was null or undefined when calling patchExpiringUserTargets.');
            }
            const localVarPath = `/flags/{projectKey}/{featureFlagKey}/expiring-user-targets/{environmentKey}`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)))
                .replace(`{${"environmentKey"}}`, encodeURIComponent(String(environmentKey)))
                .replace(`{${"featureFlagKey"}}`, encodeURIComponent(String(featureFlagKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof semanticPatchWithComment !== "string") && configuration.isJsonMime(localVarRequestOptions.headers['Content-Type']);
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(semanticPatchWithComment !== undefined ? semanticPatchWithComment : {}) : (semanticPatchWithComment || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Perform a partial update to a feature.
         * @param {string} projectKey The project key, used to tie the flags together under one project so they can be managed together.
         * @param {string} featureFlagKey The feature flag\&#39;s key. The key identifies the flag in your code.
         * @param {InlineObject2} patchComment 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchFeatureFlag: async (projectKey: string, featureFlagKey: string, patchComment: InlineObject2, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            if (projectKey === null || projectKey === undefined) {
                throw new RequiredError('projectKey','Required parameter projectKey was null or undefined when calling patchFeatureFlag.');
            }
            // verify required parameter 'featureFlagKey' is not null or undefined
            if (featureFlagKey === null || featureFlagKey === undefined) {
                throw new RequiredError('featureFlagKey','Required parameter featureFlagKey was null or undefined when calling patchFeatureFlag.');
            }
            // verify required parameter 'patchComment' is not null or undefined
            if (patchComment === null || patchComment === undefined) {
                throw new RequiredError('patchComment','Required parameter patchComment was null or undefined when calling patchFeatureFlag.');
            }
            const localVarPath = `/flags/{projectKey}/{featureFlagKey}`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)))
                .replace(`{${"featureFlagKey"}}`, encodeURIComponent(String(featureFlagKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof patchComment !== "string") && configuration.isJsonMime(localVarRequestOptions.headers['Content-Type']);
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(patchComment !== undefined ? patchComment : {}) : (patchComment || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates a new feature flag.
         * @param {string} projectKey The project key, used to tie the flags together under one project so they can be managed together.
         * @param {InlineObject1} featureFlagBody 
         * @param {string} [clone] The key of the feature flag to be cloned. The key identifies the flag in your code.  For example, setting clone&#x3D;flagKey will copy the full targeting configuration for all environments (including on/off state) from the original flag to the new flag.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postFeatureFlag: async (projectKey: string, featureFlagBody: InlineObject1, clone?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            if (projectKey === null || projectKey === undefined) {
                throw new RequiredError('projectKey','Required parameter projectKey was null or undefined when calling postFeatureFlag.');
            }
            // verify required parameter 'featureFlagBody' is not null or undefined
            if (featureFlagBody === null || featureFlagBody === undefined) {
                throw new RequiredError('featureFlagBody','Required parameter featureFlagBody was null or undefined when calling postFeatureFlag.');
            }
            const localVarPath = `/flags/{projectKey}`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (clone !== undefined) {
                localVarQueryParameter['clone'] = clone;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof featureFlagBody !== "string") && configuration.isJsonMime(localVarRequestOptions.headers['Content-Type']);
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(featureFlagBody !== undefined ? featureFlagBody : {}) : (featureFlagBody || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FeatureFlagsApi - functional programming interface
 * @export
 */
export const FeatureFlagsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Copies the feature flag configuration from one environment to the same feature flag in another environment.
         * @param {string} projectKey The project key, used to tie the flags together under one project so they can be managed together.
         * @param {string} featureFlagKey The feature flag\&#39;s key. The key identifies the flag in your code.
         * @param {InlineObject3} featureFlagCopyBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async copyFeatureFlag(projectKey: string, featureFlagKey: string, featureFlagCopyBody: InlineObject3, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FeatureFlag>> {
            const localVarAxiosArgs = await FeatureFlagsApiAxiosParamCreator(configuration).copyFeatureFlag(projectKey, featureFlagKey, featureFlagCopyBody, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Delete a feature flag in all environments. Be careful-- only delete feature flags that are no longer being used by your application.
         * @param {string} projectKey The project key, used to tie the flags together under one project so they can be managed together.
         * @param {string} featureFlagKey The feature flag\&#39;s key. The key identifies the flag in your code.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteFeatureFlag(projectKey: string, featureFlagKey: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await FeatureFlagsApiAxiosParamCreator(configuration).deleteFeatureFlag(projectKey, featureFlagKey, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get expiring user targets for feature flag
         * @param {string} projectKey The project key, used to tie the flags together under one project so they can be managed together.
         * @param {string} environmentKey The environment key, used to tie together flag configuration and users under one environment so they can be managed together.
         * @param {string} featureFlagKey The feature flag\&#39;s key. The key identifies the flag in your code.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getExpiringUserTargets(projectKey: string, environmentKey: string, featureFlagKey: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserTargetingExpirationForFlags>> {
            const localVarAxiosArgs = await FeatureFlagsApiAxiosParamCreator(configuration).getExpiringUserTargets(projectKey, environmentKey, featureFlagKey, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get a single feature flag by key.
         * @param {string} projectKey The project key, used to tie the flags together under one project so they can be managed together.
         * @param {string} featureFlagKey The feature flag\&#39;s key. The key identifies the flag in your code.
         * @param {Array<string>} [env] By default, each feature will include configurations for each environment. You can filter environments with the env query parameter. For example, setting env&#x3D;[\&quot;production\&quot;] will restrict the returned configurations to just your production environment.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFeatureFlag(projectKey: string, featureFlagKey: string, env?: Array<string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FeatureFlag>> {
            const localVarAxiosArgs = await FeatureFlagsApiAxiosParamCreator(configuration).getFeatureFlag(projectKey, featureFlagKey, env, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get the status for a particular feature flag.
         * @param {string} projectKey The project key, used to tie the flags together under one project so they can be managed together.
         * @param {string} environmentKey The environment key, used to tie together flag configuration and users under one environment so they can be managed together.
         * @param {string} featureFlagKey The feature flag\&#39;s key. The key identifies the flag in your code.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFeatureFlagStatus(projectKey: string, environmentKey: string, featureFlagKey: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FeatureFlagStatus>> {
            const localVarAxiosArgs = await FeatureFlagsApiAxiosParamCreator(configuration).getFeatureFlagStatus(projectKey, environmentKey, featureFlagKey, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get the status for a particular feature flag across environments
         * @param {string} projectKey The project key, used to tie the flags together under one project so they can be managed together.
         * @param {string} featureFlagKey The feature flag\&#39;s key. The key identifies the flag in your code.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFeatureFlagStatusAcrossEnvironments(projectKey: string, featureFlagKey: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FeatureFlagStatusAcrossEnvironments>> {
            const localVarAxiosArgs = await FeatureFlagsApiAxiosParamCreator(configuration).getFeatureFlagStatusAcrossEnvironments(projectKey, featureFlagKey, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get a list of statuses for all feature flags. The status includes the last time the feature flag was requested, as well as the state of the flag.
         * @param {string} projectKey The project key, used to tie the flags together under one project so they can be managed together.
         * @param {string} environmentKey The environment key, used to tie together flag configuration and users under one environment so they can be managed together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFeatureFlagStatuses(projectKey: string, environmentKey: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FeatureFlagStatuses>> {
            const localVarAxiosArgs = await FeatureFlagsApiAxiosParamCreator(configuration).getFeatureFlagStatuses(projectKey, environmentKey, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get a list of all features in the given project.
         * @param {string} projectKey The project key, used to tie the flags together under one project so they can be managed together.
         * @param {Array<string>} [env] By default, each feature will include configurations for each environment. You can filter environments with the env query parameter. For example, setting env&#x3D;[\&quot;production\&quot;] will restrict the returned configurations to just your production environment.
         * @param {boolean} [summary] By default in api version &gt;&#x3D; 1, flags will _not_ include their list of prerequisites, targets or rules.  Set summary&#x3D;0 to include these fields for each flag returned.
         * @param {boolean} [archived] When set to 1, only archived flags will be included in the list of flags returned.  By default, archived flags are not included in the list of flags.
         * @param {number} [limit] The number of objects to return. Defaults to -1, which returns everything.
         * @param {number} [offset] Where to start in the list. This is for use with pagination. For example, an offset of 10 would skip the first 10 items and then return the next limit items.
         * @param {string} [filter] A comma-separated list of filters. Each filter is of the form field:value.
         * @param {string} [sort] A comma-separated list of fields to sort by. A field prefixed by a - will be sorted in descending order.
         * @param {string} [tag] Filter by tag. A tag can be used to group flags across projects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFeatureFlags(projectKey: string, env?: Array<string>, summary?: boolean, archived?: boolean, limit?: number, offset?: number, filter?: string, sort?: string, tag?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FeatureFlags>> {
            const localVarAxiosArgs = await FeatureFlagsApiAxiosParamCreator(configuration).getFeatureFlags(projectKey, env, summary, archived, limit, offset, filter, sort, tag, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Update, add, or delete expiring user targets on feature flag
         * @param {string} projectKey The project key, used to tie the flags together under one project so they can be managed together.
         * @param {string} environmentKey The environment key, used to tie together flag configuration and users under one environment so they can be managed together.
         * @param {string} featureFlagKey The feature flag\&#39;s key. The key identifies the flag in your code.
         * @param {object} semanticPatchWithComment Requires a Semantic Patch representation of the desired changes to the resource. \&#39;https://apidocs.launchdarkly.com/reference#updates-via-semantic-patches\&#39;. The addition of comments is also supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchExpiringUserTargets(projectKey: string, environmentKey: string, featureFlagKey: string, semanticPatchWithComment: object, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserTargetingExpirationForFlags>> {
            const localVarAxiosArgs = await FeatureFlagsApiAxiosParamCreator(configuration).patchExpiringUserTargets(projectKey, environmentKey, featureFlagKey, semanticPatchWithComment, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Perform a partial update to a feature.
         * @param {string} projectKey The project key, used to tie the flags together under one project so they can be managed together.
         * @param {string} featureFlagKey The feature flag\&#39;s key. The key identifies the flag in your code.
         * @param {InlineObject2} patchComment 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchFeatureFlag(projectKey: string, featureFlagKey: string, patchComment: InlineObject2, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FeatureFlag>> {
            const localVarAxiosArgs = await FeatureFlagsApiAxiosParamCreator(configuration).patchFeatureFlag(projectKey, featureFlagKey, patchComment, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Creates a new feature flag.
         * @param {string} projectKey The project key, used to tie the flags together under one project so they can be managed together.
         * @param {InlineObject1} featureFlagBody 
         * @param {string} [clone] The key of the feature flag to be cloned. The key identifies the flag in your code.  For example, setting clone&#x3D;flagKey will copy the full targeting configuration for all environments (including on/off state) from the original flag to the new flag.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postFeatureFlag(projectKey: string, featureFlagBody: InlineObject1, clone?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FeatureFlag>> {
            const localVarAxiosArgs = await FeatureFlagsApiAxiosParamCreator(configuration).postFeatureFlag(projectKey, featureFlagBody, clone, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * FeatureFlagsApi - factory interface
 * @export
 */
export const FeatureFlagsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Copies the feature flag configuration from one environment to the same feature flag in another environment.
         * @param {string} projectKey The project key, used to tie the flags together under one project so they can be managed together.
         * @param {string} featureFlagKey The feature flag\&#39;s key. The key identifies the flag in your code.
         * @param {InlineObject3} featureFlagCopyBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        copyFeatureFlag(projectKey: string, featureFlagKey: string, featureFlagCopyBody: InlineObject3, options?: any): AxiosPromise<FeatureFlag> {
            return FeatureFlagsApiFp(configuration).copyFeatureFlag(projectKey, featureFlagKey, featureFlagCopyBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a feature flag in all environments. Be careful-- only delete feature flags that are no longer being used by your application.
         * @param {string} projectKey The project key, used to tie the flags together under one project so they can be managed together.
         * @param {string} featureFlagKey The feature flag\&#39;s key. The key identifies the flag in your code.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFeatureFlag(projectKey: string, featureFlagKey: string, options?: any): AxiosPromise<void> {
            return FeatureFlagsApiFp(configuration).deleteFeatureFlag(projectKey, featureFlagKey, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get expiring user targets for feature flag
         * @param {string} projectKey The project key, used to tie the flags together under one project so they can be managed together.
         * @param {string} environmentKey The environment key, used to tie together flag configuration and users under one environment so they can be managed together.
         * @param {string} featureFlagKey The feature flag\&#39;s key. The key identifies the flag in your code.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExpiringUserTargets(projectKey: string, environmentKey: string, featureFlagKey: string, options?: any): AxiosPromise<UserTargetingExpirationForFlags> {
            return FeatureFlagsApiFp(configuration).getExpiringUserTargets(projectKey, environmentKey, featureFlagKey, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a single feature flag by key.
         * @param {string} projectKey The project key, used to tie the flags together under one project so they can be managed together.
         * @param {string} featureFlagKey The feature flag\&#39;s key. The key identifies the flag in your code.
         * @param {Array<string>} [env] By default, each feature will include configurations for each environment. You can filter environments with the env query parameter. For example, setting env&#x3D;[\&quot;production\&quot;] will restrict the returned configurations to just your production environment.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFeatureFlag(projectKey: string, featureFlagKey: string, env?: Array<string>, options?: any): AxiosPromise<FeatureFlag> {
            return FeatureFlagsApiFp(configuration).getFeatureFlag(projectKey, featureFlagKey, env, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the status for a particular feature flag.
         * @param {string} projectKey The project key, used to tie the flags together under one project so they can be managed together.
         * @param {string} environmentKey The environment key, used to tie together flag configuration and users under one environment so they can be managed together.
         * @param {string} featureFlagKey The feature flag\&#39;s key. The key identifies the flag in your code.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFeatureFlagStatus(projectKey: string, environmentKey: string, featureFlagKey: string, options?: any): AxiosPromise<FeatureFlagStatus> {
            return FeatureFlagsApiFp(configuration).getFeatureFlagStatus(projectKey, environmentKey, featureFlagKey, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the status for a particular feature flag across environments
         * @param {string} projectKey The project key, used to tie the flags together under one project so they can be managed together.
         * @param {string} featureFlagKey The feature flag\&#39;s key. The key identifies the flag in your code.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFeatureFlagStatusAcrossEnvironments(projectKey: string, featureFlagKey: string, options?: any): AxiosPromise<FeatureFlagStatusAcrossEnvironments> {
            return FeatureFlagsApiFp(configuration).getFeatureFlagStatusAcrossEnvironments(projectKey, featureFlagKey, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a list of statuses for all feature flags. The status includes the last time the feature flag was requested, as well as the state of the flag.
         * @param {string} projectKey The project key, used to tie the flags together under one project so they can be managed together.
         * @param {string} environmentKey The environment key, used to tie together flag configuration and users under one environment so they can be managed together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFeatureFlagStatuses(projectKey: string, environmentKey: string, options?: any): AxiosPromise<FeatureFlagStatuses> {
            return FeatureFlagsApiFp(configuration).getFeatureFlagStatuses(projectKey, environmentKey, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a list of all features in the given project.
         * @param {string} projectKey The project key, used to tie the flags together under one project so they can be managed together.
         * @param {Array<string>} [env] By default, each feature will include configurations for each environment. You can filter environments with the env query parameter. For example, setting env&#x3D;[\&quot;production\&quot;] will restrict the returned configurations to just your production environment.
         * @param {boolean} [summary] By default in api version &gt;&#x3D; 1, flags will _not_ include their list of prerequisites, targets or rules.  Set summary&#x3D;0 to include these fields for each flag returned.
         * @param {boolean} [archived] When set to 1, only archived flags will be included in the list of flags returned.  By default, archived flags are not included in the list of flags.
         * @param {number} [limit] The number of objects to return. Defaults to -1, which returns everything.
         * @param {number} [offset] Where to start in the list. This is for use with pagination. For example, an offset of 10 would skip the first 10 items and then return the next limit items.
         * @param {string} [filter] A comma-separated list of filters. Each filter is of the form field:value.
         * @param {string} [sort] A comma-separated list of fields to sort by. A field prefixed by a - will be sorted in descending order.
         * @param {string} [tag] Filter by tag. A tag can be used to group flags across projects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFeatureFlags(projectKey: string, env?: Array<string>, summary?: boolean, archived?: boolean, limit?: number, offset?: number, filter?: string, sort?: string, tag?: string, options?: any): AxiosPromise<FeatureFlags> {
            return FeatureFlagsApiFp(configuration).getFeatureFlags(projectKey, env, summary, archived, limit, offset, filter, sort, tag, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update, add, or delete expiring user targets on feature flag
         * @param {string} projectKey The project key, used to tie the flags together under one project so they can be managed together.
         * @param {string} environmentKey The environment key, used to tie together flag configuration and users under one environment so they can be managed together.
         * @param {string} featureFlagKey The feature flag\&#39;s key. The key identifies the flag in your code.
         * @param {object} semanticPatchWithComment Requires a Semantic Patch representation of the desired changes to the resource. \&#39;https://apidocs.launchdarkly.com/reference#updates-via-semantic-patches\&#39;. The addition of comments is also supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchExpiringUserTargets(projectKey: string, environmentKey: string, featureFlagKey: string, semanticPatchWithComment: object, options?: any): AxiosPromise<UserTargetingExpirationForFlags> {
            return FeatureFlagsApiFp(configuration).patchExpiringUserTargets(projectKey, environmentKey, featureFlagKey, semanticPatchWithComment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Perform a partial update to a feature.
         * @param {string} projectKey The project key, used to tie the flags together under one project so they can be managed together.
         * @param {string} featureFlagKey The feature flag\&#39;s key. The key identifies the flag in your code.
         * @param {InlineObject2} patchComment 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchFeatureFlag(projectKey: string, featureFlagKey: string, patchComment: InlineObject2, options?: any): AxiosPromise<FeatureFlag> {
            return FeatureFlagsApiFp(configuration).patchFeatureFlag(projectKey, featureFlagKey, patchComment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Creates a new feature flag.
         * @param {string} projectKey The project key, used to tie the flags together under one project so they can be managed together.
         * @param {InlineObject1} featureFlagBody 
         * @param {string} [clone] The key of the feature flag to be cloned. The key identifies the flag in your code.  For example, setting clone&#x3D;flagKey will copy the full targeting configuration for all environments (including on/off state) from the original flag to the new flag.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postFeatureFlag(projectKey: string, featureFlagBody: InlineObject1, clone?: string, options?: any): AxiosPromise<FeatureFlag> {
            return FeatureFlagsApiFp(configuration).postFeatureFlag(projectKey, featureFlagBody, clone, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FeatureFlagsApi - object-oriented interface
 * @export
 * @class FeatureFlagsApi
 * @extends {BaseAPI}
 */
export class FeatureFlagsApi extends BaseAPI {
    /**
     * 
     * @summary Copies the feature flag configuration from one environment to the same feature flag in another environment.
     * @param {string} projectKey The project key, used to tie the flags together under one project so they can be managed together.
     * @param {string} featureFlagKey The feature flag\&#39;s key. The key identifies the flag in your code.
     * @param {InlineObject3} featureFlagCopyBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FeatureFlagsApi
     */
    public copyFeatureFlag(projectKey: string, featureFlagKey: string, featureFlagCopyBody: InlineObject3, options?: any) {
        return FeatureFlagsApiFp(this.configuration).copyFeatureFlag(projectKey, featureFlagKey, featureFlagCopyBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a feature flag in all environments. Be careful-- only delete feature flags that are no longer being used by your application.
     * @param {string} projectKey The project key, used to tie the flags together under one project so they can be managed together.
     * @param {string} featureFlagKey The feature flag\&#39;s key. The key identifies the flag in your code.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FeatureFlagsApi
     */
    public deleteFeatureFlag(projectKey: string, featureFlagKey: string, options?: any) {
        return FeatureFlagsApiFp(this.configuration).deleteFeatureFlag(projectKey, featureFlagKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get expiring user targets for feature flag
     * @param {string} projectKey The project key, used to tie the flags together under one project so they can be managed together.
     * @param {string} environmentKey The environment key, used to tie together flag configuration and users under one environment so they can be managed together.
     * @param {string} featureFlagKey The feature flag\&#39;s key. The key identifies the flag in your code.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FeatureFlagsApi
     */
    public getExpiringUserTargets(projectKey: string, environmentKey: string, featureFlagKey: string, options?: any) {
        return FeatureFlagsApiFp(this.configuration).getExpiringUserTargets(projectKey, environmentKey, featureFlagKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a single feature flag by key.
     * @param {string} projectKey The project key, used to tie the flags together under one project so they can be managed together.
     * @param {string} featureFlagKey The feature flag\&#39;s key. The key identifies the flag in your code.
     * @param {Array<string>} [env] By default, each feature will include configurations for each environment. You can filter environments with the env query parameter. For example, setting env&#x3D;[\&quot;production\&quot;] will restrict the returned configurations to just your production environment.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FeatureFlagsApi
     */
    public getFeatureFlag(projectKey: string, featureFlagKey: string, env?: Array<string>, options?: any) {
        return FeatureFlagsApiFp(this.configuration).getFeatureFlag(projectKey, featureFlagKey, env, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the status for a particular feature flag.
     * @param {string} projectKey The project key, used to tie the flags together under one project so they can be managed together.
     * @param {string} environmentKey The environment key, used to tie together flag configuration and users under one environment so they can be managed together.
     * @param {string} featureFlagKey The feature flag\&#39;s key. The key identifies the flag in your code.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FeatureFlagsApi
     */
    public getFeatureFlagStatus(projectKey: string, environmentKey: string, featureFlagKey: string, options?: any) {
        return FeatureFlagsApiFp(this.configuration).getFeatureFlagStatus(projectKey, environmentKey, featureFlagKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the status for a particular feature flag across environments
     * @param {string} projectKey The project key, used to tie the flags together under one project so they can be managed together.
     * @param {string} featureFlagKey The feature flag\&#39;s key. The key identifies the flag in your code.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FeatureFlagsApi
     */
    public getFeatureFlagStatusAcrossEnvironments(projectKey: string, featureFlagKey: string, options?: any) {
        return FeatureFlagsApiFp(this.configuration).getFeatureFlagStatusAcrossEnvironments(projectKey, featureFlagKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a list of statuses for all feature flags. The status includes the last time the feature flag was requested, as well as the state of the flag.
     * @param {string} projectKey The project key, used to tie the flags together under one project so they can be managed together.
     * @param {string} environmentKey The environment key, used to tie together flag configuration and users under one environment so they can be managed together.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FeatureFlagsApi
     */
    public getFeatureFlagStatuses(projectKey: string, environmentKey: string, options?: any) {
        return FeatureFlagsApiFp(this.configuration).getFeatureFlagStatuses(projectKey, environmentKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a list of all features in the given project.
     * @param {string} projectKey The project key, used to tie the flags together under one project so they can be managed together.
     * @param {Array<string>} [env] By default, each feature will include configurations for each environment. You can filter environments with the env query parameter. For example, setting env&#x3D;[\&quot;production\&quot;] will restrict the returned configurations to just your production environment.
     * @param {boolean} [summary] By default in api version &gt;&#x3D; 1, flags will _not_ include their list of prerequisites, targets or rules.  Set summary&#x3D;0 to include these fields for each flag returned.
     * @param {boolean} [archived] When set to 1, only archived flags will be included in the list of flags returned.  By default, archived flags are not included in the list of flags.
     * @param {number} [limit] The number of objects to return. Defaults to -1, which returns everything.
     * @param {number} [offset] Where to start in the list. This is for use with pagination. For example, an offset of 10 would skip the first 10 items and then return the next limit items.
     * @param {string} [filter] A comma-separated list of filters. Each filter is of the form field:value.
     * @param {string} [sort] A comma-separated list of fields to sort by. A field prefixed by a - will be sorted in descending order.
     * @param {string} [tag] Filter by tag. A tag can be used to group flags across projects.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FeatureFlagsApi
     */
    public getFeatureFlags(projectKey: string, env?: Array<string>, summary?: boolean, archived?: boolean, limit?: number, offset?: number, filter?: string, sort?: string, tag?: string, options?: any) {
        return FeatureFlagsApiFp(this.configuration).getFeatureFlags(projectKey, env, summary, archived, limit, offset, filter, sort, tag, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update, add, or delete expiring user targets on feature flag
     * @param {string} projectKey The project key, used to tie the flags together under one project so they can be managed together.
     * @param {string} environmentKey The environment key, used to tie together flag configuration and users under one environment so they can be managed together.
     * @param {string} featureFlagKey The feature flag\&#39;s key. The key identifies the flag in your code.
     * @param {object} semanticPatchWithComment Requires a Semantic Patch representation of the desired changes to the resource. \&#39;https://apidocs.launchdarkly.com/reference#updates-via-semantic-patches\&#39;. The addition of comments is also supported.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FeatureFlagsApi
     */
    public patchExpiringUserTargets(projectKey: string, environmentKey: string, featureFlagKey: string, semanticPatchWithComment: object, options?: any) {
        return FeatureFlagsApiFp(this.configuration).patchExpiringUserTargets(projectKey, environmentKey, featureFlagKey, semanticPatchWithComment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Perform a partial update to a feature.
     * @param {string} projectKey The project key, used to tie the flags together under one project so they can be managed together.
     * @param {string} featureFlagKey The feature flag\&#39;s key. The key identifies the flag in your code.
     * @param {InlineObject2} patchComment 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FeatureFlagsApi
     */
    public patchFeatureFlag(projectKey: string, featureFlagKey: string, patchComment: InlineObject2, options?: any) {
        return FeatureFlagsApiFp(this.configuration).patchFeatureFlag(projectKey, featureFlagKey, patchComment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Creates a new feature flag.
     * @param {string} projectKey The project key, used to tie the flags together under one project so they can be managed together.
     * @param {InlineObject1} featureFlagBody 
     * @param {string} [clone] The key of the feature flag to be cloned. The key identifies the flag in your code.  For example, setting clone&#x3D;flagKey will copy the full targeting configuration for all environments (including on/off state) from the original flag to the new flag.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FeatureFlagsApi
     */
    public postFeatureFlag(projectKey: string, featureFlagBody: InlineObject1, clone?: string, options?: any) {
        return FeatureFlagsApiFp(this.configuration).postFeatureFlag(projectKey, featureFlagBody, clone, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * IntegrationsApi - axios parameter creator
 * @export
 */
export const IntegrationsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Delete an integration subscription by ID.
         * @param {string} integrationKey The key used to specify the integration kind.
         * @param {string} integrationId The integration ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteIntegrationSubscription: async (integrationKey: string, integrationId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'integrationKey' is not null or undefined
            if (integrationKey === null || integrationKey === undefined) {
                throw new RequiredError('integrationKey','Required parameter integrationKey was null or undefined when calling deleteIntegrationSubscription.');
            }
            // verify required parameter 'integrationId' is not null or undefined
            if (integrationId === null || integrationId === undefined) {
                throw new RequiredError('integrationId','Required parameter integrationId was null or undefined when calling deleteIntegrationSubscription.');
            }
            const localVarPath = `/integrations/{integrationKey}/{integrationId}`
                .replace(`{${"integrationKey"}}`, encodeURIComponent(String(integrationKey)))
                .replace(`{${"integrationId"}}`, encodeURIComponent(String(integrationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a single integration subscription by ID.
         * @param {string} integrationKey The key used to specify the integration kind.
         * @param {string} integrationId The integration ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIntegrationSubscription: async (integrationKey: string, integrationId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'integrationKey' is not null or undefined
            if (integrationKey === null || integrationKey === undefined) {
                throw new RequiredError('integrationKey','Required parameter integrationKey was null or undefined when calling getIntegrationSubscription.');
            }
            // verify required parameter 'integrationId' is not null or undefined
            if (integrationId === null || integrationId === undefined) {
                throw new RequiredError('integrationId','Required parameter integrationId was null or undefined when calling getIntegrationSubscription.');
            }
            const localVarPath = `/integrations/{integrationKey}/{integrationId}`
                .replace(`{${"integrationKey"}}`, encodeURIComponent(String(integrationKey)))
                .replace(`{${"integrationId"}}`, encodeURIComponent(String(integrationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a list of all configured integrations of a given kind.
         * @param {string} integrationKey The key used to specify the integration kind.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIntegrationSubscriptions: async (integrationKey: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'integrationKey' is not null or undefined
            if (integrationKey === null || integrationKey === undefined) {
                throw new RequiredError('integrationKey','Required parameter integrationKey was null or undefined when calling getIntegrationSubscriptions.');
            }
            const localVarPath = `/integrations/{integrationKey}`
                .replace(`{${"integrationKey"}}`, encodeURIComponent(String(integrationKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a list of all configured audit log event integrations associated with this account.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIntegrations: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/integrations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Modify an integration subscription by ID.
         * @param {string} integrationKey The key used to specify the integration kind.
         * @param {string} integrationId The integration ID.
         * @param {Array<PatchOperation>} patchDelta Requires a JSON Patch representation of the desired changes to the project. \&#39;http://jsonpatch.com/\&#39;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchIntegrationSubscription: async (integrationKey: string, integrationId: string, patchDelta: Array<PatchOperation>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'integrationKey' is not null or undefined
            if (integrationKey === null || integrationKey === undefined) {
                throw new RequiredError('integrationKey','Required parameter integrationKey was null or undefined when calling patchIntegrationSubscription.');
            }
            // verify required parameter 'integrationId' is not null or undefined
            if (integrationId === null || integrationId === undefined) {
                throw new RequiredError('integrationId','Required parameter integrationId was null or undefined when calling patchIntegrationSubscription.');
            }
            // verify required parameter 'patchDelta' is not null or undefined
            if (patchDelta === null || patchDelta === undefined) {
                throw new RequiredError('patchDelta','Required parameter patchDelta was null or undefined when calling patchIntegrationSubscription.');
            }
            const localVarPath = `/integrations/{integrationKey}/{integrationId}`
                .replace(`{${"integrationKey"}}`, encodeURIComponent(String(integrationKey)))
                .replace(`{${"integrationId"}}`, encodeURIComponent(String(integrationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof patchDelta !== "string") && configuration.isJsonMime(localVarRequestOptions.headers['Content-Type']);
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(patchDelta !== undefined ? patchDelta : {}) : (patchDelta || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a new integration subscription of a given kind.
         * @param {string} integrationKey The key used to specify the integration kind.
         * @param {InlineObject12} subscriptionBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postIntegrationSubscription: async (integrationKey: string, subscriptionBody: InlineObject12, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'integrationKey' is not null or undefined
            if (integrationKey === null || integrationKey === undefined) {
                throw new RequiredError('integrationKey','Required parameter integrationKey was null or undefined when calling postIntegrationSubscription.');
            }
            // verify required parameter 'subscriptionBody' is not null or undefined
            if (subscriptionBody === null || subscriptionBody === undefined) {
                throw new RequiredError('subscriptionBody','Required parameter subscriptionBody was null or undefined when calling postIntegrationSubscription.');
            }
            const localVarPath = `/integrations/{integrationKey}`
                .replace(`{${"integrationKey"}}`, encodeURIComponent(String(integrationKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof subscriptionBody !== "string") && configuration.isJsonMime(localVarRequestOptions.headers['Content-Type']);
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(subscriptionBody !== undefined ? subscriptionBody : {}) : (subscriptionBody || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * IntegrationsApi - functional programming interface
 * @export
 */
export const IntegrationsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Delete an integration subscription by ID.
         * @param {string} integrationKey The key used to specify the integration kind.
         * @param {string} integrationId The integration ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteIntegrationSubscription(integrationKey: string, integrationId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await IntegrationsApiAxiosParamCreator(configuration).deleteIntegrationSubscription(integrationKey, integrationId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get a single integration subscription by ID.
         * @param {string} integrationKey The key used to specify the integration kind.
         * @param {string} integrationId The integration ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getIntegrationSubscription(integrationKey: string, integrationId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IntegrationSubscription>> {
            const localVarAxiosArgs = await IntegrationsApiAxiosParamCreator(configuration).getIntegrationSubscription(integrationKey, integrationId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get a list of all configured integrations of a given kind.
         * @param {string} integrationKey The key used to specify the integration kind.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getIntegrationSubscriptions(integrationKey: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Integration>> {
            const localVarAxiosArgs = await IntegrationsApiAxiosParamCreator(configuration).getIntegrationSubscriptions(integrationKey, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get a list of all configured audit log event integrations associated with this account.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getIntegrations(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Integrations>> {
            const localVarAxiosArgs = await IntegrationsApiAxiosParamCreator(configuration).getIntegrations(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Modify an integration subscription by ID.
         * @param {string} integrationKey The key used to specify the integration kind.
         * @param {string} integrationId The integration ID.
         * @param {Array<PatchOperation>} patchDelta Requires a JSON Patch representation of the desired changes to the project. \&#39;http://jsonpatch.com/\&#39;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchIntegrationSubscription(integrationKey: string, integrationId: string, patchDelta: Array<PatchOperation>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IntegrationSubscription>> {
            const localVarAxiosArgs = await IntegrationsApiAxiosParamCreator(configuration).patchIntegrationSubscription(integrationKey, integrationId, patchDelta, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Create a new integration subscription of a given kind.
         * @param {string} integrationKey The key used to specify the integration kind.
         * @param {InlineObject12} subscriptionBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postIntegrationSubscription(integrationKey: string, subscriptionBody: InlineObject12, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IntegrationSubscription>> {
            const localVarAxiosArgs = await IntegrationsApiAxiosParamCreator(configuration).postIntegrationSubscription(integrationKey, subscriptionBody, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * IntegrationsApi - factory interface
 * @export
 */
export const IntegrationsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Delete an integration subscription by ID.
         * @param {string} integrationKey The key used to specify the integration kind.
         * @param {string} integrationId The integration ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteIntegrationSubscription(integrationKey: string, integrationId: string, options?: any): AxiosPromise<void> {
            return IntegrationsApiFp(configuration).deleteIntegrationSubscription(integrationKey, integrationId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a single integration subscription by ID.
         * @param {string} integrationKey The key used to specify the integration kind.
         * @param {string} integrationId The integration ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIntegrationSubscription(integrationKey: string, integrationId: string, options?: any): AxiosPromise<IntegrationSubscription> {
            return IntegrationsApiFp(configuration).getIntegrationSubscription(integrationKey, integrationId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a list of all configured integrations of a given kind.
         * @param {string} integrationKey The key used to specify the integration kind.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIntegrationSubscriptions(integrationKey: string, options?: any): AxiosPromise<Integration> {
            return IntegrationsApiFp(configuration).getIntegrationSubscriptions(integrationKey, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a list of all configured audit log event integrations associated with this account.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIntegrations(options?: any): AxiosPromise<Integrations> {
            return IntegrationsApiFp(configuration).getIntegrations(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Modify an integration subscription by ID.
         * @param {string} integrationKey The key used to specify the integration kind.
         * @param {string} integrationId The integration ID.
         * @param {Array<PatchOperation>} patchDelta Requires a JSON Patch representation of the desired changes to the project. \&#39;http://jsonpatch.com/\&#39;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchIntegrationSubscription(integrationKey: string, integrationId: string, patchDelta: Array<PatchOperation>, options?: any): AxiosPromise<IntegrationSubscription> {
            return IntegrationsApiFp(configuration).patchIntegrationSubscription(integrationKey, integrationId, patchDelta, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a new integration subscription of a given kind.
         * @param {string} integrationKey The key used to specify the integration kind.
         * @param {InlineObject12} subscriptionBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postIntegrationSubscription(integrationKey: string, subscriptionBody: InlineObject12, options?: any): AxiosPromise<IntegrationSubscription> {
            return IntegrationsApiFp(configuration).postIntegrationSubscription(integrationKey, subscriptionBody, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * IntegrationsApi - object-oriented interface
 * @export
 * @class IntegrationsApi
 * @extends {BaseAPI}
 */
export class IntegrationsApi extends BaseAPI {
    /**
     * 
     * @summary Delete an integration subscription by ID.
     * @param {string} integrationKey The key used to specify the integration kind.
     * @param {string} integrationId The integration ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationsApi
     */
    public deleteIntegrationSubscription(integrationKey: string, integrationId: string, options?: any) {
        return IntegrationsApiFp(this.configuration).deleteIntegrationSubscription(integrationKey, integrationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a single integration subscription by ID.
     * @param {string} integrationKey The key used to specify the integration kind.
     * @param {string} integrationId The integration ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationsApi
     */
    public getIntegrationSubscription(integrationKey: string, integrationId: string, options?: any) {
        return IntegrationsApiFp(this.configuration).getIntegrationSubscription(integrationKey, integrationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a list of all configured integrations of a given kind.
     * @param {string} integrationKey The key used to specify the integration kind.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationsApi
     */
    public getIntegrationSubscriptions(integrationKey: string, options?: any) {
        return IntegrationsApiFp(this.configuration).getIntegrationSubscriptions(integrationKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a list of all configured audit log event integrations associated with this account.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationsApi
     */
    public getIntegrations(options?: any) {
        return IntegrationsApiFp(this.configuration).getIntegrations(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Modify an integration subscription by ID.
     * @param {string} integrationKey The key used to specify the integration kind.
     * @param {string} integrationId The integration ID.
     * @param {Array<PatchOperation>} patchDelta Requires a JSON Patch representation of the desired changes to the project. \&#39;http://jsonpatch.com/\&#39;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationsApi
     */
    public patchIntegrationSubscription(integrationKey: string, integrationId: string, patchDelta: Array<PatchOperation>, options?: any) {
        return IntegrationsApiFp(this.configuration).patchIntegrationSubscription(integrationKey, integrationId, patchDelta, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a new integration subscription of a given kind.
     * @param {string} integrationKey The key used to specify the integration kind.
     * @param {InlineObject12} subscriptionBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationsApi
     */
    public postIntegrationSubscription(integrationKey: string, subscriptionBody: InlineObject12, options?: any) {
        return IntegrationsApiFp(this.configuration).postIntegrationSubscription(integrationKey, subscriptionBody, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ProjectsApi - axios parameter creator
 * @export
 */
export const ProjectsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Delete a project by key. Caution-- deleting a project will delete all associated environments and feature flags. You cannot delete the last project in an account.
         * @param {string} projectKey The project key, used to tie the flags together under one project so they can be managed together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProject: async (projectKey: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            if (projectKey === null || projectKey === undefined) {
                throw new RequiredError('projectKey','Required parameter projectKey was null or undefined when calling deleteProject.');
            }
            const localVarPath = `/projects/{projectKey}`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Fetch a single project by key.
         * @param {string} projectKey The project key, used to tie the flags together under one project so they can be managed together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProject: async (projectKey: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            if (projectKey === null || projectKey === undefined) {
                throw new RequiredError('projectKey','Required parameter projectKey was null or undefined when calling getProject.');
            }
            const localVarPath = `/projects/{projectKey}`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns a list of all projects in the account.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjects: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/projects`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Modify a project by ID.
         * @param {string} projectKey The project key, used to tie the flags together under one project so they can be managed together.
         * @param {Array<PatchOperation>} patchDelta Requires a JSON Patch representation of the desired changes to the project. \&#39;http://jsonpatch.com/\&#39;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchProject: async (projectKey: string, patchDelta: Array<PatchOperation>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            if (projectKey === null || projectKey === undefined) {
                throw new RequiredError('projectKey','Required parameter projectKey was null or undefined when calling patchProject.');
            }
            // verify required parameter 'patchDelta' is not null or undefined
            if (patchDelta === null || patchDelta === undefined) {
                throw new RequiredError('patchDelta','Required parameter patchDelta was null or undefined when calling patchProject.');
            }
            const localVarPath = `/projects/{projectKey}`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof patchDelta !== "string") && configuration.isJsonMime(localVarRequestOptions.headers['Content-Type']);
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(patchDelta !== undefined ? patchDelta : {}) : (patchDelta || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a new project with the given key and name.
         * @param {InlineObject} projectBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postProject: async (projectBody: InlineObject, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectBody' is not null or undefined
            if (projectBody === null || projectBody === undefined) {
                throw new RequiredError('projectBody','Required parameter projectBody was null or undefined when calling postProject.');
            }
            const localVarPath = `/projects`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof projectBody !== "string") && configuration.isJsonMime(localVarRequestOptions.headers['Content-Type']);
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(projectBody !== undefined ? projectBody : {}) : (projectBody || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProjectsApi - functional programming interface
 * @export
 */
export const ProjectsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Delete a project by key. Caution-- deleting a project will delete all associated environments and feature flags. You cannot delete the last project in an account.
         * @param {string} projectKey The project key, used to tie the flags together under one project so they can be managed together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteProject(projectKey: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await ProjectsApiAxiosParamCreator(configuration).deleteProject(projectKey, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Fetch a single project by key.
         * @param {string} projectKey The project key, used to tie the flags together under one project so they can be managed together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProject(projectKey: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Project>> {
            const localVarAxiosArgs = await ProjectsApiAxiosParamCreator(configuration).getProject(projectKey, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Returns a list of all projects in the account.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProjects(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Projects>> {
            const localVarAxiosArgs = await ProjectsApiAxiosParamCreator(configuration).getProjects(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Modify a project by ID.
         * @param {string} projectKey The project key, used to tie the flags together under one project so they can be managed together.
         * @param {Array<PatchOperation>} patchDelta Requires a JSON Patch representation of the desired changes to the project. \&#39;http://jsonpatch.com/\&#39;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchProject(projectKey: string, patchDelta: Array<PatchOperation>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Project>> {
            const localVarAxiosArgs = await ProjectsApiAxiosParamCreator(configuration).patchProject(projectKey, patchDelta, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Create a new project with the given key and name.
         * @param {InlineObject} projectBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postProject(projectBody: InlineObject, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Project>> {
            const localVarAxiosArgs = await ProjectsApiAxiosParamCreator(configuration).postProject(projectBody, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * ProjectsApi - factory interface
 * @export
 */
export const ProjectsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Delete a project by key. Caution-- deleting a project will delete all associated environments and feature flags. You cannot delete the last project in an account.
         * @param {string} projectKey The project key, used to tie the flags together under one project so they can be managed together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProject(projectKey: string, options?: any): AxiosPromise<void> {
            return ProjectsApiFp(configuration).deleteProject(projectKey, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Fetch a single project by key.
         * @param {string} projectKey The project key, used to tie the flags together under one project so they can be managed together.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProject(projectKey: string, options?: any): AxiosPromise<Project> {
            return ProjectsApiFp(configuration).getProject(projectKey, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns a list of all projects in the account.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjects(options?: any): AxiosPromise<Projects> {
            return ProjectsApiFp(configuration).getProjects(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Modify a project by ID.
         * @param {string} projectKey The project key, used to tie the flags together under one project so they can be managed together.
         * @param {Array<PatchOperation>} patchDelta Requires a JSON Patch representation of the desired changes to the project. \&#39;http://jsonpatch.com/\&#39;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchProject(projectKey: string, patchDelta: Array<PatchOperation>, options?: any): AxiosPromise<Project> {
            return ProjectsApiFp(configuration).patchProject(projectKey, patchDelta, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a new project with the given key and name.
         * @param {InlineObject} projectBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postProject(projectBody: InlineObject, options?: any): AxiosPromise<Project> {
            return ProjectsApiFp(configuration).postProject(projectBody, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProjectsApi - object-oriented interface
 * @export
 * @class ProjectsApi
 * @extends {BaseAPI}
 */
export class ProjectsApi extends BaseAPI {
    /**
     * 
     * @summary Delete a project by key. Caution-- deleting a project will delete all associated environments and feature flags. You cannot delete the last project in an account.
     * @param {string} projectKey The project key, used to tie the flags together under one project so they can be managed together.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public deleteProject(projectKey: string, options?: any) {
        return ProjectsApiFp(this.configuration).deleteProject(projectKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Fetch a single project by key.
     * @param {string} projectKey The project key, used to tie the flags together under one project so they can be managed together.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public getProject(projectKey: string, options?: any) {
        return ProjectsApiFp(this.configuration).getProject(projectKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns a list of all projects in the account.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public getProjects(options?: any) {
        return ProjectsApiFp(this.configuration).getProjects(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Modify a project by ID.
     * @param {string} projectKey The project key, used to tie the flags together under one project so they can be managed together.
     * @param {Array<PatchOperation>} patchDelta Requires a JSON Patch representation of the desired changes to the project. \&#39;http://jsonpatch.com/\&#39;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public patchProject(projectKey: string, patchDelta: Array<PatchOperation>, options?: any) {
        return ProjectsApiFp(this.configuration).patchProject(projectKey, patchDelta, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a new project with the given key and name.
     * @param {InlineObject} projectBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public postProject(projectBody: InlineObject, options?: any) {
        return ProjectsApiFp(this.configuration).postProject(projectBody, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * RelayProxyConfigurationsApi - axios parameter creator
 * @export
 */
export const RelayProxyConfigurationsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Delete a relay proxy configuration by ID.
         * @param {string} id The relay proxy configuration ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRelayProxyConfig: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteRelayProxyConfig.');
            }
            const localVarPath = `/account/relay-auto-configs/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a single relay proxy configuration by ID.
         * @param {string} id The relay proxy configuration ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRelayProxyConfig: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getRelayProxyConfig.');
            }
            const localVarPath = `/account/relay-auto-configs/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns a list of relay proxy configurations in the account.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRelayProxyConfigs: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/account/relay-auto-configs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Modify a relay proxy configuration by ID.
         * @param {string} id The relay proxy configuration ID
         * @param {Array<PatchOperation>} patchDelta Requires a JSON Patch representation of the desired changes to the project. \&#39;http://jsonpatch.com/\&#39;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchRelayProxyConfig: async (id: string, patchDelta: Array<PatchOperation>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling patchRelayProxyConfig.');
            }
            // verify required parameter 'patchDelta' is not null or undefined
            if (patchDelta === null || patchDelta === undefined) {
                throw new RequiredError('patchDelta','Required parameter patchDelta was null or undefined when calling patchRelayProxyConfig.');
            }
            const localVarPath = `/account/relay-auto-configs/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof patchDelta !== "string") && configuration.isJsonMime(localVarRequestOptions.headers['Content-Type']);
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(patchDelta !== undefined ? patchDelta : {}) : (patchDelta || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a new relay proxy config.
         * @param {InlineObject11} relayProxyConfigBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postRelayAutoConfig: async (relayProxyConfigBody: InlineObject11, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'relayProxyConfigBody' is not null or undefined
            if (relayProxyConfigBody === null || relayProxyConfigBody === undefined) {
                throw new RequiredError('relayProxyConfigBody','Required parameter relayProxyConfigBody was null or undefined when calling postRelayAutoConfig.');
            }
            const localVarPath = `/account/relay-auto-configs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof relayProxyConfigBody !== "string") && configuration.isJsonMime(localVarRequestOptions.headers['Content-Type']);
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(relayProxyConfigBody !== undefined ? relayProxyConfigBody : {}) : (relayProxyConfigBody || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Reset a relay proxy configuration\'s secret key with an optional expiry time for the old key.
         * @param {string} id The relay proxy configuration ID
         * @param {number} [expiry] An expiration time for the old relay proxy configuration key, expressed as a Unix epoch time in milliseconds. By default, the relay proxy configuration will expire immediately
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetRelayProxyConfig: async (id: string, expiry?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling resetRelayProxyConfig.');
            }
            const localVarPath = `/account/relay-auto-configs/{id}/reset`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (expiry !== undefined) {
                localVarQueryParameter['expiry'] = expiry;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RelayProxyConfigurationsApi - functional programming interface
 * @export
 */
export const RelayProxyConfigurationsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Delete a relay proxy configuration by ID.
         * @param {string} id The relay proxy configuration ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteRelayProxyConfig(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await RelayProxyConfigurationsApiAxiosParamCreator(configuration).deleteRelayProxyConfig(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get a single relay proxy configuration by ID.
         * @param {string} id The relay proxy configuration ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRelayProxyConfig(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RelayProxyConfig>> {
            const localVarAxiosArgs = await RelayProxyConfigurationsApiAxiosParamCreator(configuration).getRelayProxyConfig(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Returns a list of relay proxy configurations in the account.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRelayProxyConfigs(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RelayProxyConfigs>> {
            const localVarAxiosArgs = await RelayProxyConfigurationsApiAxiosParamCreator(configuration).getRelayProxyConfigs(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Modify a relay proxy configuration by ID.
         * @param {string} id The relay proxy configuration ID
         * @param {Array<PatchOperation>} patchDelta Requires a JSON Patch representation of the desired changes to the project. \&#39;http://jsonpatch.com/\&#39;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchRelayProxyConfig(id: string, patchDelta: Array<PatchOperation>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RelayProxyConfig>> {
            const localVarAxiosArgs = await RelayProxyConfigurationsApiAxiosParamCreator(configuration).patchRelayProxyConfig(id, patchDelta, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Create a new relay proxy config.
         * @param {InlineObject11} relayProxyConfigBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postRelayAutoConfig(relayProxyConfigBody: InlineObject11, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RelayProxyConfig>> {
            const localVarAxiosArgs = await RelayProxyConfigurationsApiAxiosParamCreator(configuration).postRelayAutoConfig(relayProxyConfigBody, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Reset a relay proxy configuration\'s secret key with an optional expiry time for the old key.
         * @param {string} id The relay proxy configuration ID
         * @param {number} [expiry] An expiration time for the old relay proxy configuration key, expressed as a Unix epoch time in milliseconds. By default, the relay proxy configuration will expire immediately
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resetRelayProxyConfig(id: string, expiry?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RelayProxyConfig>> {
            const localVarAxiosArgs = await RelayProxyConfigurationsApiAxiosParamCreator(configuration).resetRelayProxyConfig(id, expiry, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * RelayProxyConfigurationsApi - factory interface
 * @export
 */
export const RelayProxyConfigurationsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Delete a relay proxy configuration by ID.
         * @param {string} id The relay proxy configuration ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRelayProxyConfig(id: string, options?: any): AxiosPromise<void> {
            return RelayProxyConfigurationsApiFp(configuration).deleteRelayProxyConfig(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a single relay proxy configuration by ID.
         * @param {string} id The relay proxy configuration ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRelayProxyConfig(id: string, options?: any): AxiosPromise<RelayProxyConfig> {
            return RelayProxyConfigurationsApiFp(configuration).getRelayProxyConfig(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns a list of relay proxy configurations in the account.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRelayProxyConfigs(options?: any): AxiosPromise<RelayProxyConfigs> {
            return RelayProxyConfigurationsApiFp(configuration).getRelayProxyConfigs(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Modify a relay proxy configuration by ID.
         * @param {string} id The relay proxy configuration ID
         * @param {Array<PatchOperation>} patchDelta Requires a JSON Patch representation of the desired changes to the project. \&#39;http://jsonpatch.com/\&#39;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchRelayProxyConfig(id: string, patchDelta: Array<PatchOperation>, options?: any): AxiosPromise<RelayProxyConfig> {
            return RelayProxyConfigurationsApiFp(configuration).patchRelayProxyConfig(id, patchDelta, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a new relay proxy config.
         * @param {InlineObject11} relayProxyConfigBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postRelayAutoConfig(relayProxyConfigBody: InlineObject11, options?: any): AxiosPromise<RelayProxyConfig> {
            return RelayProxyConfigurationsApiFp(configuration).postRelayAutoConfig(relayProxyConfigBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Reset a relay proxy configuration\'s secret key with an optional expiry time for the old key.
         * @param {string} id The relay proxy configuration ID
         * @param {number} [expiry] An expiration time for the old relay proxy configuration key, expressed as a Unix epoch time in milliseconds. By default, the relay proxy configuration will expire immediately
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetRelayProxyConfig(id: string, expiry?: number, options?: any): AxiosPromise<RelayProxyConfig> {
            return RelayProxyConfigurationsApiFp(configuration).resetRelayProxyConfig(id, expiry, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RelayProxyConfigurationsApi - object-oriented interface
 * @export
 * @class RelayProxyConfigurationsApi
 * @extends {BaseAPI}
 */
export class RelayProxyConfigurationsApi extends BaseAPI {
    /**
     * 
     * @summary Delete a relay proxy configuration by ID.
     * @param {string} id The relay proxy configuration ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RelayProxyConfigurationsApi
     */
    public deleteRelayProxyConfig(id: string, options?: any) {
        return RelayProxyConfigurationsApiFp(this.configuration).deleteRelayProxyConfig(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a single relay proxy configuration by ID.
     * @param {string} id The relay proxy configuration ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RelayProxyConfigurationsApi
     */
    public getRelayProxyConfig(id: string, options?: any) {
        return RelayProxyConfigurationsApiFp(this.configuration).getRelayProxyConfig(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns a list of relay proxy configurations in the account.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RelayProxyConfigurationsApi
     */
    public getRelayProxyConfigs(options?: any) {
        return RelayProxyConfigurationsApiFp(this.configuration).getRelayProxyConfigs(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Modify a relay proxy configuration by ID.
     * @param {string} id The relay proxy configuration ID
     * @param {Array<PatchOperation>} patchDelta Requires a JSON Patch representation of the desired changes to the project. \&#39;http://jsonpatch.com/\&#39;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RelayProxyConfigurationsApi
     */
    public patchRelayProxyConfig(id: string, patchDelta: Array<PatchOperation>, options?: any) {
        return RelayProxyConfigurationsApiFp(this.configuration).patchRelayProxyConfig(id, patchDelta, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a new relay proxy config.
     * @param {InlineObject11} relayProxyConfigBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RelayProxyConfigurationsApi
     */
    public postRelayAutoConfig(relayProxyConfigBody: InlineObject11, options?: any) {
        return RelayProxyConfigurationsApiFp(this.configuration).postRelayAutoConfig(relayProxyConfigBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Reset a relay proxy configuration\'s secret key with an optional expiry time for the old key.
     * @param {string} id The relay proxy configuration ID
     * @param {number} [expiry] An expiration time for the old relay proxy configuration key, expressed as a Unix epoch time in milliseconds. By default, the relay proxy configuration will expire immediately
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RelayProxyConfigurationsApi
     */
    public resetRelayProxyConfig(id: string, expiry?: number, options?: any) {
        return RelayProxyConfigurationsApiFp(this.configuration).resetRelayProxyConfig(id, expiry, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * RootApi - axios parameter creator
 * @export
 */
export const RootApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * You can issue a GET request to the root resource to find all of the resource categories supported by the API.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoot: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RootApi - functional programming interface
 * @export
 */
export const RootApiFp = function(configuration?: Configuration) {
    return {
        /**
         * You can issue a GET request to the root resource to find all of the resource categories supported by the API.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRoot(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Links>> {
            const localVarAxiosArgs = await RootApiAxiosParamCreator(configuration).getRoot(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * RootApi - factory interface
 * @export
 */
export const RootApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * You can issue a GET request to the root resource to find all of the resource categories supported by the API.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoot(options?: any): AxiosPromise<Links> {
            return RootApiFp(configuration).getRoot(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RootApi - object-oriented interface
 * @export
 * @class RootApi
 * @extends {BaseAPI}
 */
export class RootApi extends BaseAPI {
    /**
     * You can issue a GET request to the root resource to find all of the resource categories supported by the API.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RootApi
     */
    public getRoot(options?: any) {
        return RootApiFp(this.configuration).getRoot(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TeamMembersApi - axios parameter creator
 * @export
 */
export const TeamMembersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Delete a team member by ID.
         * @param {string} memberId The member ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMember: async (memberId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'memberId' is not null or undefined
            if (memberId === null || memberId === undefined) {
                throw new RequiredError('memberId','Required parameter memberId was null or undefined when calling deleteMember.');
            }
            const localVarPath = `/members/{memberId}`
                .replace(`{${"memberId"}}`, encodeURIComponent(String(memberId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the current team member associated with the token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMe: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/members/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a single team member by ID.
         * @param {string} memberId The member ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMember: async (memberId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'memberId' is not null or undefined
            if (memberId === null || memberId === undefined) {
                throw new RequiredError('memberId','Required parameter memberId was null or undefined when calling getMember.');
            }
            const localVarPath = `/members/{memberId}`
                .replace(`{${"memberId"}}`, encodeURIComponent(String(memberId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns a list of all members in the account.
         * @param {number} [limit] The number of objects to return. Defaults to -1, which returns everything.
         * @param {number} [offset] Where to start in the list. This is for use with pagination. For example, an offset of 10 would skip the first 10 items and then return the next limit items.
         * @param {string} [filter] A comma-separated list of filters. Each filter is of the form field:value.
         * @param {string} [sort] A comma-separated list of fields to sort by. A field prefixed by a - will be sorted in descending order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMembers: async (limit?: number, offset?: number, filter?: string, sort?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/members`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Modify a team member by ID.
         * @param {string} memberId The member ID.
         * @param {Array<PatchOperation>} patchDelta Requires a JSON Patch representation of the desired changes to the project. \&#39;http://jsonpatch.com/\&#39;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchMember: async (memberId: string, patchDelta: Array<PatchOperation>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'memberId' is not null or undefined
            if (memberId === null || memberId === undefined) {
                throw new RequiredError('memberId','Required parameter memberId was null or undefined when calling patchMember.');
            }
            // verify required parameter 'patchDelta' is not null or undefined
            if (patchDelta === null || patchDelta === undefined) {
                throw new RequiredError('patchDelta','Required parameter patchDelta was null or undefined when calling patchMember.');
            }
            const localVarPath = `/members/{memberId}`
                .replace(`{${"memberId"}}`, encodeURIComponent(String(memberId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof patchDelta !== "string") && configuration.isJsonMime(localVarRequestOptions.headers['Content-Type']);
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(patchDelta !== undefined ? patchDelta : {}) : (patchDelta || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invite new members.
         * @param {Array<InlineObject>} membersBody New members to invite.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postMembers: async (membersBody: Array<InlineObject>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'membersBody' is not null or undefined
            if (membersBody === null || membersBody === undefined) {
                throw new RequiredError('membersBody','Required parameter membersBody was null or undefined when calling postMembers.');
            }
            const localVarPath = `/members`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof membersBody !== "string") && configuration.isJsonMime(localVarRequestOptions.headers['Content-Type']);
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(membersBody !== undefined ? membersBody : {}) : (membersBody || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TeamMembersApi - functional programming interface
 * @export
 */
export const TeamMembersApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Delete a team member by ID.
         * @param {string} memberId The member ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteMember(memberId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await TeamMembersApiAxiosParamCreator(configuration).deleteMember(memberId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get the current team member associated with the token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMe(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Member>> {
            const localVarAxiosArgs = await TeamMembersApiAxiosParamCreator(configuration).getMe(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get a single team member by ID.
         * @param {string} memberId The member ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMember(memberId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Member>> {
            const localVarAxiosArgs = await TeamMembersApiAxiosParamCreator(configuration).getMember(memberId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Returns a list of all members in the account.
         * @param {number} [limit] The number of objects to return. Defaults to -1, which returns everything.
         * @param {number} [offset] Where to start in the list. This is for use with pagination. For example, an offset of 10 would skip the first 10 items and then return the next limit items.
         * @param {string} [filter] A comma-separated list of filters. Each filter is of the form field:value.
         * @param {string} [sort] A comma-separated list of fields to sort by. A field prefixed by a - will be sorted in descending order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMembers(limit?: number, offset?: number, filter?: string, sort?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Members>> {
            const localVarAxiosArgs = await TeamMembersApiAxiosParamCreator(configuration).getMembers(limit, offset, filter, sort, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Modify a team member by ID.
         * @param {string} memberId The member ID.
         * @param {Array<PatchOperation>} patchDelta Requires a JSON Patch representation of the desired changes to the project. \&#39;http://jsonpatch.com/\&#39;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchMember(memberId: string, patchDelta: Array<PatchOperation>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Member>> {
            const localVarAxiosArgs = await TeamMembersApiAxiosParamCreator(configuration).patchMember(memberId, patchDelta, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Invite new members.
         * @param {Array<InlineObject>} membersBody New members to invite.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postMembers(membersBody: Array<InlineObject>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Members>> {
            const localVarAxiosArgs = await TeamMembersApiAxiosParamCreator(configuration).postMembers(membersBody, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * TeamMembersApi - factory interface
 * @export
 */
export const TeamMembersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Delete a team member by ID.
         * @param {string} memberId The member ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMember(memberId: string, options?: any): AxiosPromise<void> {
            return TeamMembersApiFp(configuration).deleteMember(memberId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the current team member associated with the token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMe(options?: any): AxiosPromise<Member> {
            return TeamMembersApiFp(configuration).getMe(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a single team member by ID.
         * @param {string} memberId The member ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMember(memberId: string, options?: any): AxiosPromise<Member> {
            return TeamMembersApiFp(configuration).getMember(memberId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns a list of all members in the account.
         * @param {number} [limit] The number of objects to return. Defaults to -1, which returns everything.
         * @param {number} [offset] Where to start in the list. This is for use with pagination. For example, an offset of 10 would skip the first 10 items and then return the next limit items.
         * @param {string} [filter] A comma-separated list of filters. Each filter is of the form field:value.
         * @param {string} [sort] A comma-separated list of fields to sort by. A field prefixed by a - will be sorted in descending order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMembers(limit?: number, offset?: number, filter?: string, sort?: string, options?: any): AxiosPromise<Members> {
            return TeamMembersApiFp(configuration).getMembers(limit, offset, filter, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Modify a team member by ID.
         * @param {string} memberId The member ID.
         * @param {Array<PatchOperation>} patchDelta Requires a JSON Patch representation of the desired changes to the project. \&#39;http://jsonpatch.com/\&#39;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchMember(memberId: string, patchDelta: Array<PatchOperation>, options?: any): AxiosPromise<Member> {
            return TeamMembersApiFp(configuration).patchMember(memberId, patchDelta, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Invite new members.
         * @param {Array<InlineObject>} membersBody New members to invite.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postMembers(membersBody: Array<InlineObject>, options?: any): AxiosPromise<Members> {
            return TeamMembersApiFp(configuration).postMembers(membersBody, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TeamMembersApi - object-oriented interface
 * @export
 * @class TeamMembersApi
 * @extends {BaseAPI}
 */
export class TeamMembersApi extends BaseAPI {
    /**
     * 
     * @summary Delete a team member by ID.
     * @param {string} memberId The member ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamMembersApi
     */
    public deleteMember(memberId: string, options?: any) {
        return TeamMembersApiFp(this.configuration).deleteMember(memberId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the current team member associated with the token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamMembersApi
     */
    public getMe(options?: any) {
        return TeamMembersApiFp(this.configuration).getMe(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a single team member by ID.
     * @param {string} memberId The member ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamMembersApi
     */
    public getMember(memberId: string, options?: any) {
        return TeamMembersApiFp(this.configuration).getMember(memberId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns a list of all members in the account.
     * @param {number} [limit] The number of objects to return. Defaults to -1, which returns everything.
     * @param {number} [offset] Where to start in the list. This is for use with pagination. For example, an offset of 10 would skip the first 10 items and then return the next limit items.
     * @param {string} [filter] A comma-separated list of filters. Each filter is of the form field:value.
     * @param {string} [sort] A comma-separated list of fields to sort by. A field prefixed by a - will be sorted in descending order.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamMembersApi
     */
    public getMembers(limit?: number, offset?: number, filter?: string, sort?: string, options?: any) {
        return TeamMembersApiFp(this.configuration).getMembers(limit, offset, filter, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Modify a team member by ID.
     * @param {string} memberId The member ID.
     * @param {Array<PatchOperation>} patchDelta Requires a JSON Patch representation of the desired changes to the project. \&#39;http://jsonpatch.com/\&#39;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamMembersApi
     */
    public patchMember(memberId: string, patchDelta: Array<PatchOperation>, options?: any) {
        return TeamMembersApiFp(this.configuration).patchMember(memberId, patchDelta, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Invite new members.
     * @param {Array<InlineObject>} membersBody New members to invite.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamMembersApi
     */
    public postMembers(membersBody: Array<InlineObject>, options?: any) {
        return TeamMembersApiFp(this.configuration).postMembers(membersBody, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UserSegmentsApi - axios parameter creator
 * @export
 */
export const UserSegmentsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Delete a user segment.
         * @param {string} projectKey The project key, used to tie the flags together under one project so they can be managed together.
         * @param {string} environmentKey The environment key, used to tie together flag configuration and users under one environment so they can be managed together.
         * @param {string} userSegmentKey The user segment\&#39;s key. The key identifies the user segment in your code.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserSegment: async (projectKey: string, environmentKey: string, userSegmentKey: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            if (projectKey === null || projectKey === undefined) {
                throw new RequiredError('projectKey','Required parameter projectKey was null or undefined when calling deleteUserSegment.');
            }
            // verify required parameter 'environmentKey' is not null or undefined
            if (environmentKey === null || environmentKey === undefined) {
                throw new RequiredError('environmentKey','Required parameter environmentKey was null or undefined when calling deleteUserSegment.');
            }
            // verify required parameter 'userSegmentKey' is not null or undefined
            if (userSegmentKey === null || userSegmentKey === undefined) {
                throw new RequiredError('userSegmentKey','Required parameter userSegmentKey was null or undefined when calling deleteUserSegment.');
            }
            const localVarPath = `/segments/{projectKey}/{environmentKey}/{userSegmentKey}`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)))
                .replace(`{${"environmentKey"}}`, encodeURIComponent(String(environmentKey)))
                .replace(`{${"userSegmentKey"}}`, encodeURIComponent(String(userSegmentKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get expiring user targets for user segment
         * @param {string} projectKey The project key, used to tie the flags together under one project so they can be managed together.
         * @param {string} environmentKey The environment key, used to tie together flag configuration and users under one environment so they can be managed together.
         * @param {string} userSegmentKey The user segment\&#39;s key. The key identifies the user segment in your code.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExpiringUserTargetsOnSegment: async (projectKey: string, environmentKey: string, userSegmentKey: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            if (projectKey === null || projectKey === undefined) {
                throw new RequiredError('projectKey','Required parameter projectKey was null or undefined when calling getExpiringUserTargetsOnSegment.');
            }
            // verify required parameter 'environmentKey' is not null or undefined
            if (environmentKey === null || environmentKey === undefined) {
                throw new RequiredError('environmentKey','Required parameter environmentKey was null or undefined when calling getExpiringUserTargetsOnSegment.');
            }
            // verify required parameter 'userSegmentKey' is not null or undefined
            if (userSegmentKey === null || userSegmentKey === undefined) {
                throw new RequiredError('userSegmentKey','Required parameter userSegmentKey was null or undefined when calling getExpiringUserTargetsOnSegment.');
            }
            const localVarPath = `/segments/{projectKey}/{userSegmentKey}/expiring-user-targets/{environmentKey}`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)))
                .replace(`{${"environmentKey"}}`, encodeURIComponent(String(environmentKey)))
                .replace(`{${"userSegmentKey"}}`, encodeURIComponent(String(userSegmentKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a single user segment by key.
         * @param {string} projectKey The project key, used to tie the flags together under one project so they can be managed together.
         * @param {string} environmentKey The environment key, used to tie together flag configuration and users under one environment so they can be managed together.
         * @param {string} userSegmentKey The user segment\&#39;s key. The key identifies the user segment in your code.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserSegment: async (projectKey: string, environmentKey: string, userSegmentKey: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            if (projectKey === null || projectKey === undefined) {
                throw new RequiredError('projectKey','Required parameter projectKey was null or undefined when calling getUserSegment.');
            }
            // verify required parameter 'environmentKey' is not null or undefined
            if (environmentKey === null || environmentKey === undefined) {
                throw new RequiredError('environmentKey','Required parameter environmentKey was null or undefined when calling getUserSegment.');
            }
            // verify required parameter 'userSegmentKey' is not null or undefined
            if (userSegmentKey === null || userSegmentKey === undefined) {
                throw new RequiredError('userSegmentKey','Required parameter userSegmentKey was null or undefined when calling getUserSegment.');
            }
            const localVarPath = `/segments/{projectKey}/{environmentKey}/{userSegmentKey}`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)))
                .replace(`{${"environmentKey"}}`, encodeURIComponent(String(environmentKey)))
                .replace(`{${"userSegmentKey"}}`, encodeURIComponent(String(userSegmentKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a list of all user segments in the given project.
         * @param {string} projectKey The project key, used to tie the flags together under one project so they can be managed together.
         * @param {string} environmentKey The environment key, used to tie together flag configuration and users under one environment so they can be managed together.
         * @param {string} [tag] Filter by tag. A tag can be used to group flags across projects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserSegments: async (projectKey: string, environmentKey: string, tag?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            if (projectKey === null || projectKey === undefined) {
                throw new RequiredError('projectKey','Required parameter projectKey was null or undefined when calling getUserSegments.');
            }
            // verify required parameter 'environmentKey' is not null or undefined
            if (environmentKey === null || environmentKey === undefined) {
                throw new RequiredError('environmentKey','Required parameter environmentKey was null or undefined when calling getUserSegments.');
            }
            const localVarPath = `/segments/{projectKey}/{environmentKey}`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)))
                .replace(`{${"environmentKey"}}`, encodeURIComponent(String(environmentKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (tag !== undefined) {
                localVarQueryParameter['tag'] = tag;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update, add, or delete expiring user targets on user segment
         * @param {string} projectKey The project key, used to tie the flags together under one project so they can be managed together.
         * @param {string} environmentKey The environment key, used to tie together flag configuration and users under one environment so they can be managed together.
         * @param {string} userSegmentKey The user segment\&#39;s key. The key identifies the user segment in your code.
         * @param {object} semanticPatchWithComment Requires a Semantic Patch representation of the desired changes to the resource. \&#39;https://apidocs.launchdarkly.com/reference#updates-via-semantic-patches\&#39;. The addition of comments is also supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchExpiringUserTargetsOnSegment: async (projectKey: string, environmentKey: string, userSegmentKey: string, semanticPatchWithComment: object, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            if (projectKey === null || projectKey === undefined) {
                throw new RequiredError('projectKey','Required parameter projectKey was null or undefined when calling patchExpiringUserTargetsOnSegment.');
            }
            // verify required parameter 'environmentKey' is not null or undefined
            if (environmentKey === null || environmentKey === undefined) {
                throw new RequiredError('environmentKey','Required parameter environmentKey was null or undefined when calling patchExpiringUserTargetsOnSegment.');
            }
            // verify required parameter 'userSegmentKey' is not null or undefined
            if (userSegmentKey === null || userSegmentKey === undefined) {
                throw new RequiredError('userSegmentKey','Required parameter userSegmentKey was null or undefined when calling patchExpiringUserTargetsOnSegment.');
            }
            // verify required parameter 'semanticPatchWithComment' is not null or undefined
            if (semanticPatchWithComment === null || semanticPatchWithComment === undefined) {
                throw new RequiredError('semanticPatchWithComment','Required parameter semanticPatchWithComment was null or undefined when calling patchExpiringUserTargetsOnSegment.');
            }
            const localVarPath = `/segments/{projectKey}/{userSegmentKey}/expiring-user-targets/{environmentKey}`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)))
                .replace(`{${"environmentKey"}}`, encodeURIComponent(String(environmentKey)))
                .replace(`{${"userSegmentKey"}}`, encodeURIComponent(String(userSegmentKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof semanticPatchWithComment !== "string") && configuration.isJsonMime(localVarRequestOptions.headers['Content-Type']);
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(semanticPatchWithComment !== undefined ? semanticPatchWithComment : {}) : (semanticPatchWithComment || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Perform a partial update to a user segment.
         * @param {string} projectKey The project key, used to tie the flags together under one project so they can be managed together.
         * @param {string} environmentKey The environment key, used to tie together flag configuration and users under one environment so they can be managed together.
         * @param {string} userSegmentKey The user segment\&#39;s key. The key identifies the user segment in your code.
         * @param {Array<PatchOperation>} patchOnly Requires a JSON Patch representation of the desired changes to the project. \&#39;http://jsonpatch.com/\&#39; Feature flag patches also support JSON Merge Patch format. \&#39;https://tools.ietf.org/html/rfc7386\&#39; The addition of comments is also supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchUserSegment: async (projectKey: string, environmentKey: string, userSegmentKey: string, patchOnly: Array<PatchOperation>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            if (projectKey === null || projectKey === undefined) {
                throw new RequiredError('projectKey','Required parameter projectKey was null or undefined when calling patchUserSegment.');
            }
            // verify required parameter 'environmentKey' is not null or undefined
            if (environmentKey === null || environmentKey === undefined) {
                throw new RequiredError('environmentKey','Required parameter environmentKey was null or undefined when calling patchUserSegment.');
            }
            // verify required parameter 'userSegmentKey' is not null or undefined
            if (userSegmentKey === null || userSegmentKey === undefined) {
                throw new RequiredError('userSegmentKey','Required parameter userSegmentKey was null or undefined when calling patchUserSegment.');
            }
            // verify required parameter 'patchOnly' is not null or undefined
            if (patchOnly === null || patchOnly === undefined) {
                throw new RequiredError('patchOnly','Required parameter patchOnly was null or undefined when calling patchUserSegment.');
            }
            const localVarPath = `/segments/{projectKey}/{environmentKey}/{userSegmentKey}`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)))
                .replace(`{${"environmentKey"}}`, encodeURIComponent(String(environmentKey)))
                .replace(`{${"userSegmentKey"}}`, encodeURIComponent(String(userSegmentKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof patchOnly !== "string") && configuration.isJsonMime(localVarRequestOptions.headers['Content-Type']);
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(patchOnly !== undefined ? patchOnly : {}) : (patchOnly || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates a new user segment.
         * @param {string} projectKey The project key, used to tie the flags together under one project so they can be managed together.
         * @param {string} environmentKey The environment key, used to tie together flag configuration and users under one environment so they can be managed together.
         * @param {InlineObject4} userSegmentBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUserSegment: async (projectKey: string, environmentKey: string, userSegmentBody: InlineObject4, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            if (projectKey === null || projectKey === undefined) {
                throw new RequiredError('projectKey','Required parameter projectKey was null or undefined when calling postUserSegment.');
            }
            // verify required parameter 'environmentKey' is not null or undefined
            if (environmentKey === null || environmentKey === undefined) {
                throw new RequiredError('environmentKey','Required parameter environmentKey was null or undefined when calling postUserSegment.');
            }
            // verify required parameter 'userSegmentBody' is not null or undefined
            if (userSegmentBody === null || userSegmentBody === undefined) {
                throw new RequiredError('userSegmentBody','Required parameter userSegmentBody was null or undefined when calling postUserSegment.');
            }
            const localVarPath = `/segments/{projectKey}/{environmentKey}`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)))
                .replace(`{${"environmentKey"}}`, encodeURIComponent(String(environmentKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof userSegmentBody !== "string") && configuration.isJsonMime(localVarRequestOptions.headers['Content-Type']);
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(userSegmentBody !== undefined ? userSegmentBody : {}) : (userSegmentBody || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update targets included or excluded in an unbounded segment
         * @param {string} projectKey The project key, used to tie the flags together under one project so they can be managed together.
         * @param {string} environmentKey The environment key, used to tie together flag configuration and users under one environment so they can be managed together.
         * @param {string} userSegmentKey The user segment\&#39;s key. The key identifies the user segment in your code.
         * @param {InlineObject5} unboundedSegmentTargetsBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatedUnboundedSegmentTargets: async (projectKey: string, environmentKey: string, userSegmentKey: string, unboundedSegmentTargetsBody: InlineObject5, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            if (projectKey === null || projectKey === undefined) {
                throw new RequiredError('projectKey','Required parameter projectKey was null or undefined when calling updatedUnboundedSegmentTargets.');
            }
            // verify required parameter 'environmentKey' is not null or undefined
            if (environmentKey === null || environmentKey === undefined) {
                throw new RequiredError('environmentKey','Required parameter environmentKey was null or undefined when calling updatedUnboundedSegmentTargets.');
            }
            // verify required parameter 'userSegmentKey' is not null or undefined
            if (userSegmentKey === null || userSegmentKey === undefined) {
                throw new RequiredError('userSegmentKey','Required parameter userSegmentKey was null or undefined when calling updatedUnboundedSegmentTargets.');
            }
            // verify required parameter 'unboundedSegmentTargetsBody' is not null or undefined
            if (unboundedSegmentTargetsBody === null || unboundedSegmentTargetsBody === undefined) {
                throw new RequiredError('unboundedSegmentTargetsBody','Required parameter unboundedSegmentTargetsBody was null or undefined when calling updatedUnboundedSegmentTargets.');
            }
            const localVarPath = `/segments/{projectKey}/{environmentKey}/{userSegmentKey}/unbounded-users`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)))
                .replace(`{${"environmentKey"}}`, encodeURIComponent(String(environmentKey)))
                .replace(`{${"userSegmentKey"}}`, encodeURIComponent(String(userSegmentKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof unboundedSegmentTargetsBody !== "string") && configuration.isJsonMime(localVarRequestOptions.headers['Content-Type']);
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(unboundedSegmentTargetsBody !== undefined ? unboundedSegmentTargetsBody : {}) : (unboundedSegmentTargetsBody || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserSegmentsApi - functional programming interface
 * @export
 */
export const UserSegmentsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Delete a user segment.
         * @param {string} projectKey The project key, used to tie the flags together under one project so they can be managed together.
         * @param {string} environmentKey The environment key, used to tie together flag configuration and users under one environment so they can be managed together.
         * @param {string} userSegmentKey The user segment\&#39;s key. The key identifies the user segment in your code.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteUserSegment(projectKey: string, environmentKey: string, userSegmentKey: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await UserSegmentsApiAxiosParamCreator(configuration).deleteUserSegment(projectKey, environmentKey, userSegmentKey, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get expiring user targets for user segment
         * @param {string} projectKey The project key, used to tie the flags together under one project so they can be managed together.
         * @param {string} environmentKey The environment key, used to tie together flag configuration and users under one environment so they can be managed together.
         * @param {string} userSegmentKey The user segment\&#39;s key. The key identifies the user segment in your code.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getExpiringUserTargetsOnSegment(projectKey: string, environmentKey: string, userSegmentKey: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserTargetingExpirationForSegment>> {
            const localVarAxiosArgs = await UserSegmentsApiAxiosParamCreator(configuration).getExpiringUserTargetsOnSegment(projectKey, environmentKey, userSegmentKey, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get a single user segment by key.
         * @param {string} projectKey The project key, used to tie the flags together under one project so they can be managed together.
         * @param {string} environmentKey The environment key, used to tie together flag configuration and users under one environment so they can be managed together.
         * @param {string} userSegmentKey The user segment\&#39;s key. The key identifies the user segment in your code.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserSegment(projectKey: string, environmentKey: string, userSegmentKey: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserSegment>> {
            const localVarAxiosArgs = await UserSegmentsApiAxiosParamCreator(configuration).getUserSegment(projectKey, environmentKey, userSegmentKey, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get a list of all user segments in the given project.
         * @param {string} projectKey The project key, used to tie the flags together under one project so they can be managed together.
         * @param {string} environmentKey The environment key, used to tie together flag configuration and users under one environment so they can be managed together.
         * @param {string} [tag] Filter by tag. A tag can be used to group flags across projects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserSegments(projectKey: string, environmentKey: string, tag?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserSegments>> {
            const localVarAxiosArgs = await UserSegmentsApiAxiosParamCreator(configuration).getUserSegments(projectKey, environmentKey, tag, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Update, add, or delete expiring user targets on user segment
         * @param {string} projectKey The project key, used to tie the flags together under one project so they can be managed together.
         * @param {string} environmentKey The environment key, used to tie together flag configuration and users under one environment so they can be managed together.
         * @param {string} userSegmentKey The user segment\&#39;s key. The key identifies the user segment in your code.
         * @param {object} semanticPatchWithComment Requires a Semantic Patch representation of the desired changes to the resource. \&#39;https://apidocs.launchdarkly.com/reference#updates-via-semantic-patches\&#39;. The addition of comments is also supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchExpiringUserTargetsOnSegment(projectKey: string, environmentKey: string, userSegmentKey: string, semanticPatchWithComment: object, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserTargetingExpirationForSegment>> {
            const localVarAxiosArgs = await UserSegmentsApiAxiosParamCreator(configuration).patchExpiringUserTargetsOnSegment(projectKey, environmentKey, userSegmentKey, semanticPatchWithComment, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Perform a partial update to a user segment.
         * @param {string} projectKey The project key, used to tie the flags together under one project so they can be managed together.
         * @param {string} environmentKey The environment key, used to tie together flag configuration and users under one environment so they can be managed together.
         * @param {string} userSegmentKey The user segment\&#39;s key. The key identifies the user segment in your code.
         * @param {Array<PatchOperation>} patchOnly Requires a JSON Patch representation of the desired changes to the project. \&#39;http://jsonpatch.com/\&#39; Feature flag patches also support JSON Merge Patch format. \&#39;https://tools.ietf.org/html/rfc7386\&#39; The addition of comments is also supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchUserSegment(projectKey: string, environmentKey: string, userSegmentKey: string, patchOnly: Array<PatchOperation>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserSegment>> {
            const localVarAxiosArgs = await UserSegmentsApiAxiosParamCreator(configuration).patchUserSegment(projectKey, environmentKey, userSegmentKey, patchOnly, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Creates a new user segment.
         * @param {string} projectKey The project key, used to tie the flags together under one project so they can be managed together.
         * @param {string} environmentKey The environment key, used to tie together flag configuration and users under one environment so they can be managed together.
         * @param {InlineObject4} userSegmentBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postUserSegment(projectKey: string, environmentKey: string, userSegmentBody: InlineObject4, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserSegment>> {
            const localVarAxiosArgs = await UserSegmentsApiAxiosParamCreator(configuration).postUserSegment(projectKey, environmentKey, userSegmentBody, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Update targets included or excluded in an unbounded segment
         * @param {string} projectKey The project key, used to tie the flags together under one project so they can be managed together.
         * @param {string} environmentKey The environment key, used to tie together flag configuration and users under one environment so they can be managed together.
         * @param {string} userSegmentKey The user segment\&#39;s key. The key identifies the user segment in your code.
         * @param {InlineObject5} unboundedSegmentTargetsBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatedUnboundedSegmentTargets(projectKey: string, environmentKey: string, userSegmentKey: string, unboundedSegmentTargetsBody: InlineObject5, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await UserSegmentsApiAxiosParamCreator(configuration).updatedUnboundedSegmentTargets(projectKey, environmentKey, userSegmentKey, unboundedSegmentTargetsBody, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * UserSegmentsApi - factory interface
 * @export
 */
export const UserSegmentsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Delete a user segment.
         * @param {string} projectKey The project key, used to tie the flags together under one project so they can be managed together.
         * @param {string} environmentKey The environment key, used to tie together flag configuration and users under one environment so they can be managed together.
         * @param {string} userSegmentKey The user segment\&#39;s key. The key identifies the user segment in your code.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserSegment(projectKey: string, environmentKey: string, userSegmentKey: string, options?: any): AxiosPromise<void> {
            return UserSegmentsApiFp(configuration).deleteUserSegment(projectKey, environmentKey, userSegmentKey, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get expiring user targets for user segment
         * @param {string} projectKey The project key, used to tie the flags together under one project so they can be managed together.
         * @param {string} environmentKey The environment key, used to tie together flag configuration and users under one environment so they can be managed together.
         * @param {string} userSegmentKey The user segment\&#39;s key. The key identifies the user segment in your code.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExpiringUserTargetsOnSegment(projectKey: string, environmentKey: string, userSegmentKey: string, options?: any): AxiosPromise<UserTargetingExpirationForSegment> {
            return UserSegmentsApiFp(configuration).getExpiringUserTargetsOnSegment(projectKey, environmentKey, userSegmentKey, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a single user segment by key.
         * @param {string} projectKey The project key, used to tie the flags together under one project so they can be managed together.
         * @param {string} environmentKey The environment key, used to tie together flag configuration and users under one environment so they can be managed together.
         * @param {string} userSegmentKey The user segment\&#39;s key. The key identifies the user segment in your code.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserSegment(projectKey: string, environmentKey: string, userSegmentKey: string, options?: any): AxiosPromise<UserSegment> {
            return UserSegmentsApiFp(configuration).getUserSegment(projectKey, environmentKey, userSegmentKey, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a list of all user segments in the given project.
         * @param {string} projectKey The project key, used to tie the flags together under one project so they can be managed together.
         * @param {string} environmentKey The environment key, used to tie together flag configuration and users under one environment so they can be managed together.
         * @param {string} [tag] Filter by tag. A tag can be used to group flags across projects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserSegments(projectKey: string, environmentKey: string, tag?: string, options?: any): AxiosPromise<UserSegments> {
            return UserSegmentsApiFp(configuration).getUserSegments(projectKey, environmentKey, tag, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update, add, or delete expiring user targets on user segment
         * @param {string} projectKey The project key, used to tie the flags together under one project so they can be managed together.
         * @param {string} environmentKey The environment key, used to tie together flag configuration and users under one environment so they can be managed together.
         * @param {string} userSegmentKey The user segment\&#39;s key. The key identifies the user segment in your code.
         * @param {object} semanticPatchWithComment Requires a Semantic Patch representation of the desired changes to the resource. \&#39;https://apidocs.launchdarkly.com/reference#updates-via-semantic-patches\&#39;. The addition of comments is also supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchExpiringUserTargetsOnSegment(projectKey: string, environmentKey: string, userSegmentKey: string, semanticPatchWithComment: object, options?: any): AxiosPromise<UserTargetingExpirationForSegment> {
            return UserSegmentsApiFp(configuration).patchExpiringUserTargetsOnSegment(projectKey, environmentKey, userSegmentKey, semanticPatchWithComment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Perform a partial update to a user segment.
         * @param {string} projectKey The project key, used to tie the flags together under one project so they can be managed together.
         * @param {string} environmentKey The environment key, used to tie together flag configuration and users under one environment so they can be managed together.
         * @param {string} userSegmentKey The user segment\&#39;s key. The key identifies the user segment in your code.
         * @param {Array<PatchOperation>} patchOnly Requires a JSON Patch representation of the desired changes to the project. \&#39;http://jsonpatch.com/\&#39; Feature flag patches also support JSON Merge Patch format. \&#39;https://tools.ietf.org/html/rfc7386\&#39; The addition of comments is also supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchUserSegment(projectKey: string, environmentKey: string, userSegmentKey: string, patchOnly: Array<PatchOperation>, options?: any): AxiosPromise<UserSegment> {
            return UserSegmentsApiFp(configuration).patchUserSegment(projectKey, environmentKey, userSegmentKey, patchOnly, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Creates a new user segment.
         * @param {string} projectKey The project key, used to tie the flags together under one project so they can be managed together.
         * @param {string} environmentKey The environment key, used to tie together flag configuration and users under one environment so they can be managed together.
         * @param {InlineObject4} userSegmentBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUserSegment(projectKey: string, environmentKey: string, userSegmentBody: InlineObject4, options?: any): AxiosPromise<UserSegment> {
            return UserSegmentsApiFp(configuration).postUserSegment(projectKey, environmentKey, userSegmentBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update targets included or excluded in an unbounded segment
         * @param {string} projectKey The project key, used to tie the flags together under one project so they can be managed together.
         * @param {string} environmentKey The environment key, used to tie together flag configuration and users under one environment so they can be managed together.
         * @param {string} userSegmentKey The user segment\&#39;s key. The key identifies the user segment in your code.
         * @param {InlineObject5} unboundedSegmentTargetsBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatedUnboundedSegmentTargets(projectKey: string, environmentKey: string, userSegmentKey: string, unboundedSegmentTargetsBody: InlineObject5, options?: any): AxiosPromise<void> {
            return UserSegmentsApiFp(configuration).updatedUnboundedSegmentTargets(projectKey, environmentKey, userSegmentKey, unboundedSegmentTargetsBody, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserSegmentsApi - object-oriented interface
 * @export
 * @class UserSegmentsApi
 * @extends {BaseAPI}
 */
export class UserSegmentsApi extends BaseAPI {
    /**
     * 
     * @summary Delete a user segment.
     * @param {string} projectKey The project key, used to tie the flags together under one project so they can be managed together.
     * @param {string} environmentKey The environment key, used to tie together flag configuration and users under one environment so they can be managed together.
     * @param {string} userSegmentKey The user segment\&#39;s key. The key identifies the user segment in your code.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserSegmentsApi
     */
    public deleteUserSegment(projectKey: string, environmentKey: string, userSegmentKey: string, options?: any) {
        return UserSegmentsApiFp(this.configuration).deleteUserSegment(projectKey, environmentKey, userSegmentKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get expiring user targets for user segment
     * @param {string} projectKey The project key, used to tie the flags together under one project so they can be managed together.
     * @param {string} environmentKey The environment key, used to tie together flag configuration and users under one environment so they can be managed together.
     * @param {string} userSegmentKey The user segment\&#39;s key. The key identifies the user segment in your code.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserSegmentsApi
     */
    public getExpiringUserTargetsOnSegment(projectKey: string, environmentKey: string, userSegmentKey: string, options?: any) {
        return UserSegmentsApiFp(this.configuration).getExpiringUserTargetsOnSegment(projectKey, environmentKey, userSegmentKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a single user segment by key.
     * @param {string} projectKey The project key, used to tie the flags together under one project so they can be managed together.
     * @param {string} environmentKey The environment key, used to tie together flag configuration and users under one environment so they can be managed together.
     * @param {string} userSegmentKey The user segment\&#39;s key. The key identifies the user segment in your code.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserSegmentsApi
     */
    public getUserSegment(projectKey: string, environmentKey: string, userSegmentKey: string, options?: any) {
        return UserSegmentsApiFp(this.configuration).getUserSegment(projectKey, environmentKey, userSegmentKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a list of all user segments in the given project.
     * @param {string} projectKey The project key, used to tie the flags together under one project so they can be managed together.
     * @param {string} environmentKey The environment key, used to tie together flag configuration and users under one environment so they can be managed together.
     * @param {string} [tag] Filter by tag. A tag can be used to group flags across projects.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserSegmentsApi
     */
    public getUserSegments(projectKey: string, environmentKey: string, tag?: string, options?: any) {
        return UserSegmentsApiFp(this.configuration).getUserSegments(projectKey, environmentKey, tag, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update, add, or delete expiring user targets on user segment
     * @param {string} projectKey The project key, used to tie the flags together under one project so they can be managed together.
     * @param {string} environmentKey The environment key, used to tie together flag configuration and users under one environment so they can be managed together.
     * @param {string} userSegmentKey The user segment\&#39;s key. The key identifies the user segment in your code.
     * @param {object} semanticPatchWithComment Requires a Semantic Patch representation of the desired changes to the resource. \&#39;https://apidocs.launchdarkly.com/reference#updates-via-semantic-patches\&#39;. The addition of comments is also supported.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserSegmentsApi
     */
    public patchExpiringUserTargetsOnSegment(projectKey: string, environmentKey: string, userSegmentKey: string, semanticPatchWithComment: object, options?: any) {
        return UserSegmentsApiFp(this.configuration).patchExpiringUserTargetsOnSegment(projectKey, environmentKey, userSegmentKey, semanticPatchWithComment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Perform a partial update to a user segment.
     * @param {string} projectKey The project key, used to tie the flags together under one project so they can be managed together.
     * @param {string} environmentKey The environment key, used to tie together flag configuration and users under one environment so they can be managed together.
     * @param {string} userSegmentKey The user segment\&#39;s key. The key identifies the user segment in your code.
     * @param {Array<PatchOperation>} patchOnly Requires a JSON Patch representation of the desired changes to the project. \&#39;http://jsonpatch.com/\&#39; Feature flag patches also support JSON Merge Patch format. \&#39;https://tools.ietf.org/html/rfc7386\&#39; The addition of comments is also supported.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserSegmentsApi
     */
    public patchUserSegment(projectKey: string, environmentKey: string, userSegmentKey: string, patchOnly: Array<PatchOperation>, options?: any) {
        return UserSegmentsApiFp(this.configuration).patchUserSegment(projectKey, environmentKey, userSegmentKey, patchOnly, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Creates a new user segment.
     * @param {string} projectKey The project key, used to tie the flags together under one project so they can be managed together.
     * @param {string} environmentKey The environment key, used to tie together flag configuration and users under one environment so they can be managed together.
     * @param {InlineObject4} userSegmentBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserSegmentsApi
     */
    public postUserSegment(projectKey: string, environmentKey: string, userSegmentBody: InlineObject4, options?: any) {
        return UserSegmentsApiFp(this.configuration).postUserSegment(projectKey, environmentKey, userSegmentBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update targets included or excluded in an unbounded segment
     * @param {string} projectKey The project key, used to tie the flags together under one project so they can be managed together.
     * @param {string} environmentKey The environment key, used to tie together flag configuration and users under one environment so they can be managed together.
     * @param {string} userSegmentKey The user segment\&#39;s key. The key identifies the user segment in your code.
     * @param {InlineObject5} unboundedSegmentTargetsBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserSegmentsApi
     */
    public updatedUnboundedSegmentTargets(projectKey: string, environmentKey: string, userSegmentKey: string, unboundedSegmentTargetsBody: InlineObject5, options?: any) {
        return UserSegmentsApiFp(this.configuration).updatedUnboundedSegmentTargets(projectKey, environmentKey, userSegmentKey, unboundedSegmentTargetsBody, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UserSettingsApi - axios parameter creator
 * @export
 */
export const UserSettingsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get expiring dates on flags for user
         * @param {string} projectKey The project key, used to tie the flags together under one project so they can be managed together.
         * @param {string} environmentKey The environment key, used to tie together flag configuration and users under one environment so they can be managed together.
         * @param {string} userKey The user\&#39;s key.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExpiringUserTargetsForUser: async (projectKey: string, environmentKey: string, userKey: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            if (projectKey === null || projectKey === undefined) {
                throw new RequiredError('projectKey','Required parameter projectKey was null or undefined when calling getExpiringUserTargetsForUser.');
            }
            // verify required parameter 'environmentKey' is not null or undefined
            if (environmentKey === null || environmentKey === undefined) {
                throw new RequiredError('environmentKey','Required parameter environmentKey was null or undefined when calling getExpiringUserTargetsForUser.');
            }
            // verify required parameter 'userKey' is not null or undefined
            if (userKey === null || userKey === undefined) {
                throw new RequiredError('userKey','Required parameter userKey was null or undefined when calling getExpiringUserTargetsForUser.');
            }
            const localVarPath = `/users/{projectKey}/{userKey}/expiring-user-targets/{environmentKey}`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)))
                .replace(`{${"environmentKey"}}`, encodeURIComponent(String(environmentKey)))
                .replace(`{${"userKey"}}`, encodeURIComponent(String(userKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Fetch a single flag setting for a user by key.
         * @param {string} projectKey The project key, used to tie the flags together under one project so they can be managed together.
         * @param {string} environmentKey The environment key, used to tie together flag configuration and users under one environment so they can be managed together.
         * @param {string} userKey The user\&#39;s key.
         * @param {string} featureFlagKey The feature flag\&#39;s key. The key identifies the flag in your code.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserFlagSetting: async (projectKey: string, environmentKey: string, userKey: string, featureFlagKey: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            if (projectKey === null || projectKey === undefined) {
                throw new RequiredError('projectKey','Required parameter projectKey was null or undefined when calling getUserFlagSetting.');
            }
            // verify required parameter 'environmentKey' is not null or undefined
            if (environmentKey === null || environmentKey === undefined) {
                throw new RequiredError('environmentKey','Required parameter environmentKey was null or undefined when calling getUserFlagSetting.');
            }
            // verify required parameter 'userKey' is not null or undefined
            if (userKey === null || userKey === undefined) {
                throw new RequiredError('userKey','Required parameter userKey was null or undefined when calling getUserFlagSetting.');
            }
            // verify required parameter 'featureFlagKey' is not null or undefined
            if (featureFlagKey === null || featureFlagKey === undefined) {
                throw new RequiredError('featureFlagKey','Required parameter featureFlagKey was null or undefined when calling getUserFlagSetting.');
            }
            const localVarPath = `/users/{projectKey}/{environmentKey}/{userKey}/flags/{featureFlagKey}`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)))
                .replace(`{${"environmentKey"}}`, encodeURIComponent(String(environmentKey)))
                .replace(`{${"userKey"}}`, encodeURIComponent(String(userKey)))
                .replace(`{${"featureFlagKey"}}`, encodeURIComponent(String(featureFlagKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Fetch a single flag setting for a user by key.
         * @param {string} projectKey The project key, used to tie the flags together under one project so they can be managed together.
         * @param {string} environmentKey The environment key, used to tie together flag configuration and users under one environment so they can be managed together.
         * @param {string} userKey The user\&#39;s key.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserFlagSettings: async (projectKey: string, environmentKey: string, userKey: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            if (projectKey === null || projectKey === undefined) {
                throw new RequiredError('projectKey','Required parameter projectKey was null or undefined when calling getUserFlagSettings.');
            }
            // verify required parameter 'environmentKey' is not null or undefined
            if (environmentKey === null || environmentKey === undefined) {
                throw new RequiredError('environmentKey','Required parameter environmentKey was null or undefined when calling getUserFlagSettings.');
            }
            // verify required parameter 'userKey' is not null or undefined
            if (userKey === null || userKey === undefined) {
                throw new RequiredError('userKey','Required parameter userKey was null or undefined when calling getUserFlagSettings.');
            }
            const localVarPath = `/users/{projectKey}/{environmentKey}/{userKey}/flags`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)))
                .replace(`{${"environmentKey"}}`, encodeURIComponent(String(environmentKey)))
                .replace(`{${"userKey"}}`, encodeURIComponent(String(userKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update, add, or delete expiring user targets for a single user on all flags
         * @param {string} projectKey The project key, used to tie the flags together under one project so they can be managed together.
         * @param {string} environmentKey The environment key, used to tie together flag configuration and users under one environment so they can be managed together.
         * @param {string} userKey The user\&#39;s key.
         * @param {object} semanticPatchWithComment Requires a Semantic Patch representation of the desired changes to the resource. \&#39;https://apidocs.launchdarkly.com/reference#updates-via-semantic-patches\&#39;. The addition of comments is also supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchExpiringUserTargetsForFlags: async (projectKey: string, environmentKey: string, userKey: string, semanticPatchWithComment: object, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            if (projectKey === null || projectKey === undefined) {
                throw new RequiredError('projectKey','Required parameter projectKey was null or undefined when calling patchExpiringUserTargetsForFlags.');
            }
            // verify required parameter 'environmentKey' is not null or undefined
            if (environmentKey === null || environmentKey === undefined) {
                throw new RequiredError('environmentKey','Required parameter environmentKey was null or undefined when calling patchExpiringUserTargetsForFlags.');
            }
            // verify required parameter 'userKey' is not null or undefined
            if (userKey === null || userKey === undefined) {
                throw new RequiredError('userKey','Required parameter userKey was null or undefined when calling patchExpiringUserTargetsForFlags.');
            }
            // verify required parameter 'semanticPatchWithComment' is not null or undefined
            if (semanticPatchWithComment === null || semanticPatchWithComment === undefined) {
                throw new RequiredError('semanticPatchWithComment','Required parameter semanticPatchWithComment was null or undefined when calling patchExpiringUserTargetsForFlags.');
            }
            const localVarPath = `/users/{projectKey}/{userKey}/expiring-user-targets/{environmentKey}`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)))
                .replace(`{${"environmentKey"}}`, encodeURIComponent(String(environmentKey)))
                .replace(`{${"userKey"}}`, encodeURIComponent(String(userKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof semanticPatchWithComment !== "string") && configuration.isJsonMime(localVarRequestOptions.headers['Content-Type']);
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(semanticPatchWithComment !== undefined ? semanticPatchWithComment : {}) : (semanticPatchWithComment || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Specifically enable or disable a feature flag for a user based on their key.
         * @param {string} projectKey The project key, used to tie the flags together under one project so they can be managed together.
         * @param {string} environmentKey The environment key, used to tie together flag configuration and users under one environment so they can be managed together.
         * @param {string} userKey The user\&#39;s key.
         * @param {string} featureFlagKey The feature flag\&#39;s key. The key identifies the flag in your code.
         * @param {InlineObject6} userSettingsBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putFlagSetting: async (projectKey: string, environmentKey: string, userKey: string, featureFlagKey: string, userSettingsBody: InlineObject6, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            if (projectKey === null || projectKey === undefined) {
                throw new RequiredError('projectKey','Required parameter projectKey was null or undefined when calling putFlagSetting.');
            }
            // verify required parameter 'environmentKey' is not null or undefined
            if (environmentKey === null || environmentKey === undefined) {
                throw new RequiredError('environmentKey','Required parameter environmentKey was null or undefined when calling putFlagSetting.');
            }
            // verify required parameter 'userKey' is not null or undefined
            if (userKey === null || userKey === undefined) {
                throw new RequiredError('userKey','Required parameter userKey was null or undefined when calling putFlagSetting.');
            }
            // verify required parameter 'featureFlagKey' is not null or undefined
            if (featureFlagKey === null || featureFlagKey === undefined) {
                throw new RequiredError('featureFlagKey','Required parameter featureFlagKey was null or undefined when calling putFlagSetting.');
            }
            // verify required parameter 'userSettingsBody' is not null or undefined
            if (userSettingsBody === null || userSettingsBody === undefined) {
                throw new RequiredError('userSettingsBody','Required parameter userSettingsBody was null or undefined when calling putFlagSetting.');
            }
            const localVarPath = `/users/{projectKey}/{environmentKey}/{userKey}/flags/{featureFlagKey}`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)))
                .replace(`{${"environmentKey"}}`, encodeURIComponent(String(environmentKey)))
                .replace(`{${"userKey"}}`, encodeURIComponent(String(userKey)))
                .replace(`{${"featureFlagKey"}}`, encodeURIComponent(String(featureFlagKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof userSettingsBody !== "string") && configuration.isJsonMime(localVarRequestOptions.headers['Content-Type']);
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(userSettingsBody !== undefined ? userSettingsBody : {}) : (userSettingsBody || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserSettingsApi - functional programming interface
 * @export
 */
export const UserSettingsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get expiring dates on flags for user
         * @param {string} projectKey The project key, used to tie the flags together under one project so they can be managed together.
         * @param {string} environmentKey The environment key, used to tie together flag configuration and users under one environment so they can be managed together.
         * @param {string} userKey The user\&#39;s key.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getExpiringUserTargetsForUser(projectKey: string, environmentKey: string, userKey: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserTargetingExpirationOnFlagsForUser>> {
            const localVarAxiosArgs = await UserSettingsApiAxiosParamCreator(configuration).getExpiringUserTargetsForUser(projectKey, environmentKey, userKey, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Fetch a single flag setting for a user by key.
         * @param {string} projectKey The project key, used to tie the flags together under one project so they can be managed together.
         * @param {string} environmentKey The environment key, used to tie together flag configuration and users under one environment so they can be managed together.
         * @param {string} userKey The user\&#39;s key.
         * @param {string} featureFlagKey The feature flag\&#39;s key. The key identifies the flag in your code.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserFlagSetting(projectKey: string, environmentKey: string, userKey: string, featureFlagKey: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserFlagSetting>> {
            const localVarAxiosArgs = await UserSettingsApiAxiosParamCreator(configuration).getUserFlagSetting(projectKey, environmentKey, userKey, featureFlagKey, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Fetch a single flag setting for a user by key.
         * @param {string} projectKey The project key, used to tie the flags together under one project so they can be managed together.
         * @param {string} environmentKey The environment key, used to tie together flag configuration and users under one environment so they can be managed together.
         * @param {string} userKey The user\&#39;s key.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserFlagSettings(projectKey: string, environmentKey: string, userKey: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserFlagSettings>> {
            const localVarAxiosArgs = await UserSettingsApiAxiosParamCreator(configuration).getUserFlagSettings(projectKey, environmentKey, userKey, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Update, add, or delete expiring user targets for a single user on all flags
         * @param {string} projectKey The project key, used to tie the flags together under one project so they can be managed together.
         * @param {string} environmentKey The environment key, used to tie together flag configuration and users under one environment so they can be managed together.
         * @param {string} userKey The user\&#39;s key.
         * @param {object} semanticPatchWithComment Requires a Semantic Patch representation of the desired changes to the resource. \&#39;https://apidocs.launchdarkly.com/reference#updates-via-semantic-patches\&#39;. The addition of comments is also supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchExpiringUserTargetsForFlags(projectKey: string, environmentKey: string, userKey: string, semanticPatchWithComment: object, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserTargetingExpirationOnFlagsForUser>> {
            const localVarAxiosArgs = await UserSettingsApiAxiosParamCreator(configuration).patchExpiringUserTargetsForFlags(projectKey, environmentKey, userKey, semanticPatchWithComment, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Specifically enable or disable a feature flag for a user based on their key.
         * @param {string} projectKey The project key, used to tie the flags together under one project so they can be managed together.
         * @param {string} environmentKey The environment key, used to tie together flag configuration and users under one environment so they can be managed together.
         * @param {string} userKey The user\&#39;s key.
         * @param {string} featureFlagKey The feature flag\&#39;s key. The key identifies the flag in your code.
         * @param {InlineObject6} userSettingsBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putFlagSetting(projectKey: string, environmentKey: string, userKey: string, featureFlagKey: string, userSettingsBody: InlineObject6, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await UserSettingsApiAxiosParamCreator(configuration).putFlagSetting(projectKey, environmentKey, userKey, featureFlagKey, userSettingsBody, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * UserSettingsApi - factory interface
 * @export
 */
export const UserSettingsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Get expiring dates on flags for user
         * @param {string} projectKey The project key, used to tie the flags together under one project so they can be managed together.
         * @param {string} environmentKey The environment key, used to tie together flag configuration and users under one environment so they can be managed together.
         * @param {string} userKey The user\&#39;s key.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExpiringUserTargetsForUser(projectKey: string, environmentKey: string, userKey: string, options?: any): AxiosPromise<UserTargetingExpirationOnFlagsForUser> {
            return UserSettingsApiFp(configuration).getExpiringUserTargetsForUser(projectKey, environmentKey, userKey, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Fetch a single flag setting for a user by key.
         * @param {string} projectKey The project key, used to tie the flags together under one project so they can be managed together.
         * @param {string} environmentKey The environment key, used to tie together flag configuration and users under one environment so they can be managed together.
         * @param {string} userKey The user\&#39;s key.
         * @param {string} featureFlagKey The feature flag\&#39;s key. The key identifies the flag in your code.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserFlagSetting(projectKey: string, environmentKey: string, userKey: string, featureFlagKey: string, options?: any): AxiosPromise<UserFlagSetting> {
            return UserSettingsApiFp(configuration).getUserFlagSetting(projectKey, environmentKey, userKey, featureFlagKey, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Fetch a single flag setting for a user by key.
         * @param {string} projectKey The project key, used to tie the flags together under one project so they can be managed together.
         * @param {string} environmentKey The environment key, used to tie together flag configuration and users under one environment so they can be managed together.
         * @param {string} userKey The user\&#39;s key.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserFlagSettings(projectKey: string, environmentKey: string, userKey: string, options?: any): AxiosPromise<UserFlagSettings> {
            return UserSettingsApiFp(configuration).getUserFlagSettings(projectKey, environmentKey, userKey, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update, add, or delete expiring user targets for a single user on all flags
         * @param {string} projectKey The project key, used to tie the flags together under one project so they can be managed together.
         * @param {string} environmentKey The environment key, used to tie together flag configuration and users under one environment so they can be managed together.
         * @param {string} userKey The user\&#39;s key.
         * @param {object} semanticPatchWithComment Requires a Semantic Patch representation of the desired changes to the resource. \&#39;https://apidocs.launchdarkly.com/reference#updates-via-semantic-patches\&#39;. The addition of comments is also supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchExpiringUserTargetsForFlags(projectKey: string, environmentKey: string, userKey: string, semanticPatchWithComment: object, options?: any): AxiosPromise<UserTargetingExpirationOnFlagsForUser> {
            return UserSettingsApiFp(configuration).patchExpiringUserTargetsForFlags(projectKey, environmentKey, userKey, semanticPatchWithComment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Specifically enable or disable a feature flag for a user based on their key.
         * @param {string} projectKey The project key, used to tie the flags together under one project so they can be managed together.
         * @param {string} environmentKey The environment key, used to tie together flag configuration and users under one environment so they can be managed together.
         * @param {string} userKey The user\&#39;s key.
         * @param {string} featureFlagKey The feature flag\&#39;s key. The key identifies the flag in your code.
         * @param {InlineObject6} userSettingsBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putFlagSetting(projectKey: string, environmentKey: string, userKey: string, featureFlagKey: string, userSettingsBody: InlineObject6, options?: any): AxiosPromise<void> {
            return UserSettingsApiFp(configuration).putFlagSetting(projectKey, environmentKey, userKey, featureFlagKey, userSettingsBody, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserSettingsApi - object-oriented interface
 * @export
 * @class UserSettingsApi
 * @extends {BaseAPI}
 */
export class UserSettingsApi extends BaseAPI {
    /**
     * 
     * @summary Get expiring dates on flags for user
     * @param {string} projectKey The project key, used to tie the flags together under one project so they can be managed together.
     * @param {string} environmentKey The environment key, used to tie together flag configuration and users under one environment so they can be managed together.
     * @param {string} userKey The user\&#39;s key.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserSettingsApi
     */
    public getExpiringUserTargetsForUser(projectKey: string, environmentKey: string, userKey: string, options?: any) {
        return UserSettingsApiFp(this.configuration).getExpiringUserTargetsForUser(projectKey, environmentKey, userKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Fetch a single flag setting for a user by key.
     * @param {string} projectKey The project key, used to tie the flags together under one project so they can be managed together.
     * @param {string} environmentKey The environment key, used to tie together flag configuration and users under one environment so they can be managed together.
     * @param {string} userKey The user\&#39;s key.
     * @param {string} featureFlagKey The feature flag\&#39;s key. The key identifies the flag in your code.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserSettingsApi
     */
    public getUserFlagSetting(projectKey: string, environmentKey: string, userKey: string, featureFlagKey: string, options?: any) {
        return UserSettingsApiFp(this.configuration).getUserFlagSetting(projectKey, environmentKey, userKey, featureFlagKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Fetch a single flag setting for a user by key.
     * @param {string} projectKey The project key, used to tie the flags together under one project so they can be managed together.
     * @param {string} environmentKey The environment key, used to tie together flag configuration and users under one environment so they can be managed together.
     * @param {string} userKey The user\&#39;s key.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserSettingsApi
     */
    public getUserFlagSettings(projectKey: string, environmentKey: string, userKey: string, options?: any) {
        return UserSettingsApiFp(this.configuration).getUserFlagSettings(projectKey, environmentKey, userKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update, add, or delete expiring user targets for a single user on all flags
     * @param {string} projectKey The project key, used to tie the flags together under one project so they can be managed together.
     * @param {string} environmentKey The environment key, used to tie together flag configuration and users under one environment so they can be managed together.
     * @param {string} userKey The user\&#39;s key.
     * @param {object} semanticPatchWithComment Requires a Semantic Patch representation of the desired changes to the resource. \&#39;https://apidocs.launchdarkly.com/reference#updates-via-semantic-patches\&#39;. The addition of comments is also supported.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserSettingsApi
     */
    public patchExpiringUserTargetsForFlags(projectKey: string, environmentKey: string, userKey: string, semanticPatchWithComment: object, options?: any) {
        return UserSettingsApiFp(this.configuration).patchExpiringUserTargetsForFlags(projectKey, environmentKey, userKey, semanticPatchWithComment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Specifically enable or disable a feature flag for a user based on their key.
     * @param {string} projectKey The project key, used to tie the flags together under one project so they can be managed together.
     * @param {string} environmentKey The environment key, used to tie together flag configuration and users under one environment so they can be managed together.
     * @param {string} userKey The user\&#39;s key.
     * @param {string} featureFlagKey The feature flag\&#39;s key. The key identifies the flag in your code.
     * @param {InlineObject6} userSettingsBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserSettingsApi
     */
    public putFlagSetting(projectKey: string, environmentKey: string, userKey: string, featureFlagKey: string, userSettingsBody: InlineObject6, options?: any) {
        return UserSettingsApiFp(this.configuration).putFlagSetting(projectKey, environmentKey, userKey, featureFlagKey, userSettingsBody, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UsersApi - axios parameter creator
 * @export
 */
export const UsersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Delete a user by ID.
         * @param {string} projectKey The project key, used to tie the flags together under one project so they can be managed together.
         * @param {string} environmentKey The environment key, used to tie together flag configuration and users under one environment so they can be managed together.
         * @param {string} userKey The user\&#39;s key.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser: async (projectKey: string, environmentKey: string, userKey: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            if (projectKey === null || projectKey === undefined) {
                throw new RequiredError('projectKey','Required parameter projectKey was null or undefined when calling deleteUser.');
            }
            // verify required parameter 'environmentKey' is not null or undefined
            if (environmentKey === null || environmentKey === undefined) {
                throw new RequiredError('environmentKey','Required parameter environmentKey was null or undefined when calling deleteUser.');
            }
            // verify required parameter 'userKey' is not null or undefined
            if (userKey === null || userKey === undefined) {
                throw new RequiredError('userKey','Required parameter userKey was null or undefined when calling deleteUser.');
            }
            const localVarPath = `/users/{projectKey}/{environmentKey}/{userKey}`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)))
                .replace(`{${"environmentKey"}}`, encodeURIComponent(String(environmentKey)))
                .replace(`{${"userKey"}}`, encodeURIComponent(String(userKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Search users in LaunchDarkly based on their last active date, or a search query. It should not be used to enumerate all users in LaunchDarkly-- use the List users API resource.
         * @param {string} projectKey The project key, used to tie the flags together under one project so they can be managed together.
         * @param {string} environmentKey The environment key, used to tie together flag configuration and users under one environment so they can be managed together.
         * @param {string} [q] Search query.
         * @param {number} [limit] Pagination limit.
         * @param {number} [offset] Specifies the first item to return in the collection.
         * @param {number} [after] A timestamp filter, expressed as a Unix epoch time in milliseconds. All entries returned will have occurred after this timestamp.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSearchUsers: async (projectKey: string, environmentKey: string, q?: string, limit?: number, offset?: number, after?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            if (projectKey === null || projectKey === undefined) {
                throw new RequiredError('projectKey','Required parameter projectKey was null or undefined when calling getSearchUsers.');
            }
            // verify required parameter 'environmentKey' is not null or undefined
            if (environmentKey === null || environmentKey === undefined) {
                throw new RequiredError('environmentKey','Required parameter environmentKey was null or undefined when calling getSearchUsers.');
            }
            const localVarPath = `/user-search/{projectKey}/{environmentKey}`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)))
                .replace(`{${"environmentKey"}}`, encodeURIComponent(String(environmentKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (after !== undefined) {
                localVarQueryParameter['after'] = after;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a user by key.
         * @param {string} projectKey The project key, used to tie the flags together under one project so they can be managed together.
         * @param {string} environmentKey The environment key, used to tie together flag configuration and users under one environment so they can be managed together.
         * @param {string} userKey The user\&#39;s key.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser: async (projectKey: string, environmentKey: string, userKey: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            if (projectKey === null || projectKey === undefined) {
                throw new RequiredError('projectKey','Required parameter projectKey was null or undefined when calling getUser.');
            }
            // verify required parameter 'environmentKey' is not null or undefined
            if (environmentKey === null || environmentKey === undefined) {
                throw new RequiredError('environmentKey','Required parameter environmentKey was null or undefined when calling getUser.');
            }
            // verify required parameter 'userKey' is not null or undefined
            if (userKey === null || userKey === undefined) {
                throw new RequiredError('userKey','Required parameter userKey was null or undefined when calling getUser.');
            }
            const localVarPath = `/users/{projectKey}/{environmentKey}/{userKey}`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)))
                .replace(`{${"environmentKey"}}`, encodeURIComponent(String(environmentKey)))
                .replace(`{${"userKey"}}`, encodeURIComponent(String(userKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all users in the environment. Includes the total count of users. In each page, there will be up to \'limit\' users returned (default 20). This is useful for exporting all users in the system for further analysis. Paginated collections will include a next link containing a URL with the next set of elements in the collection.
         * @param {string} projectKey The project key, used to tie the flags together under one project so they can be managed together.
         * @param {string} environmentKey The environment key, used to tie together flag configuration and users under one environment so they can be managed together.
         * @param {number} [limit] Pagination limit.
         * @param {string} [h] This parameter is required when following \&quot;next\&quot; links.
         * @param {string} [scrollId] This parameter is required when following \&quot;next\&quot; links.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsers: async (projectKey: string, environmentKey: string, limit?: number, h?: string, scrollId?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectKey' is not null or undefined
            if (projectKey === null || projectKey === undefined) {
                throw new RequiredError('projectKey','Required parameter projectKey was null or undefined when calling getUsers.');
            }
            // verify required parameter 'environmentKey' is not null or undefined
            if (environmentKey === null || environmentKey === undefined) {
                throw new RequiredError('environmentKey','Required parameter environmentKey was null or undefined when calling getUsers.');
            }
            const localVarPath = `/users/{projectKey}/{environmentKey}`
                .replace(`{${"projectKey"}}`, encodeURIComponent(String(projectKey)))
                .replace(`{${"environmentKey"}}`, encodeURIComponent(String(environmentKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (h !== undefined) {
                localVarQueryParameter['h'] = h;
            }

            if (scrollId !== undefined) {
                localVarQueryParameter['scrollId'] = scrollId;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsersApi - functional programming interface
 * @export
 */
export const UsersApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Delete a user by ID.
         * @param {string} projectKey The project key, used to tie the flags together under one project so they can be managed together.
         * @param {string} environmentKey The environment key, used to tie together flag configuration and users under one environment so they can be managed together.
         * @param {string} userKey The user\&#39;s key.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteUser(projectKey: string, environmentKey: string, userKey: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await UsersApiAxiosParamCreator(configuration).deleteUser(projectKey, environmentKey, userKey, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Search users in LaunchDarkly based on their last active date, or a search query. It should not be used to enumerate all users in LaunchDarkly-- use the List users API resource.
         * @param {string} projectKey The project key, used to tie the flags together under one project so they can be managed together.
         * @param {string} environmentKey The environment key, used to tie together flag configuration and users under one environment so they can be managed together.
         * @param {string} [q] Search query.
         * @param {number} [limit] Pagination limit.
         * @param {number} [offset] Specifies the first item to return in the collection.
         * @param {number} [after] A timestamp filter, expressed as a Unix epoch time in milliseconds. All entries returned will have occurred after this timestamp.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSearchUsers(projectKey: string, environmentKey: string, q?: string, limit?: number, offset?: number, after?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Users>> {
            const localVarAxiosArgs = await UsersApiAxiosParamCreator(configuration).getSearchUsers(projectKey, environmentKey, q, limit, offset, after, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get a user by key.
         * @param {string} projectKey The project key, used to tie the flags together under one project so they can be managed together.
         * @param {string} environmentKey The environment key, used to tie together flag configuration and users under one environment so they can be managed together.
         * @param {string} userKey The user\&#39;s key.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUser(projectKey: string, environmentKey: string, userKey: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await UsersApiAxiosParamCreator(configuration).getUser(projectKey, environmentKey, userKey, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary List all users in the environment. Includes the total count of users. In each page, there will be up to \'limit\' users returned (default 20). This is useful for exporting all users in the system for further analysis. Paginated collections will include a next link containing a URL with the next set of elements in the collection.
         * @param {string} projectKey The project key, used to tie the flags together under one project so they can be managed together.
         * @param {string} environmentKey The environment key, used to tie together flag configuration and users under one environment so they can be managed together.
         * @param {number} [limit] Pagination limit.
         * @param {string} [h] This parameter is required when following \&quot;next\&quot; links.
         * @param {string} [scrollId] This parameter is required when following \&quot;next\&quot; links.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUsers(projectKey: string, environmentKey: string, limit?: number, h?: string, scrollId?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Users>> {
            const localVarAxiosArgs = await UsersApiAxiosParamCreator(configuration).getUsers(projectKey, environmentKey, limit, h, scrollId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * UsersApi - factory interface
 * @export
 */
export const UsersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Delete a user by ID.
         * @param {string} projectKey The project key, used to tie the flags together under one project so they can be managed together.
         * @param {string} environmentKey The environment key, used to tie together flag configuration and users under one environment so they can be managed together.
         * @param {string} userKey The user\&#39;s key.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser(projectKey: string, environmentKey: string, userKey: string, options?: any): AxiosPromise<void> {
            return UsersApiFp(configuration).deleteUser(projectKey, environmentKey, userKey, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Search users in LaunchDarkly based on their last active date, or a search query. It should not be used to enumerate all users in LaunchDarkly-- use the List users API resource.
         * @param {string} projectKey The project key, used to tie the flags together under one project so they can be managed together.
         * @param {string} environmentKey The environment key, used to tie together flag configuration and users under one environment so they can be managed together.
         * @param {string} [q] Search query.
         * @param {number} [limit] Pagination limit.
         * @param {number} [offset] Specifies the first item to return in the collection.
         * @param {number} [after] A timestamp filter, expressed as a Unix epoch time in milliseconds. All entries returned will have occurred after this timestamp.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSearchUsers(projectKey: string, environmentKey: string, q?: string, limit?: number, offset?: number, after?: number, options?: any): AxiosPromise<Users> {
            return UsersApiFp(configuration).getSearchUsers(projectKey, environmentKey, q, limit, offset, after, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a user by key.
         * @param {string} projectKey The project key, used to tie the flags together under one project so they can be managed together.
         * @param {string} environmentKey The environment key, used to tie together flag configuration and users under one environment so they can be managed together.
         * @param {string} userKey The user\&#39;s key.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser(projectKey: string, environmentKey: string, userKey: string, options?: any): AxiosPromise<User> {
            return UsersApiFp(configuration).getUser(projectKey, environmentKey, userKey, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List all users in the environment. Includes the total count of users. In each page, there will be up to \'limit\' users returned (default 20). This is useful for exporting all users in the system for further analysis. Paginated collections will include a next link containing a URL with the next set of elements in the collection.
         * @param {string} projectKey The project key, used to tie the flags together under one project so they can be managed together.
         * @param {string} environmentKey The environment key, used to tie together flag configuration and users under one environment so they can be managed together.
         * @param {number} [limit] Pagination limit.
         * @param {string} [h] This parameter is required when following \&quot;next\&quot; links.
         * @param {string} [scrollId] This parameter is required when following \&quot;next\&quot; links.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsers(projectKey: string, environmentKey: string, limit?: number, h?: string, scrollId?: string, options?: any): AxiosPromise<Users> {
            return UsersApiFp(configuration).getUsers(projectKey, environmentKey, limit, h, scrollId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
export class UsersApi extends BaseAPI {
    /**
     * 
     * @summary Delete a user by ID.
     * @param {string} projectKey The project key, used to tie the flags together under one project so they can be managed together.
     * @param {string} environmentKey The environment key, used to tie together flag configuration and users under one environment so they can be managed together.
     * @param {string} userKey The user\&#39;s key.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public deleteUser(projectKey: string, environmentKey: string, userKey: string, options?: any) {
        return UsersApiFp(this.configuration).deleteUser(projectKey, environmentKey, userKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Search users in LaunchDarkly based on their last active date, or a search query. It should not be used to enumerate all users in LaunchDarkly-- use the List users API resource.
     * @param {string} projectKey The project key, used to tie the flags together under one project so they can be managed together.
     * @param {string} environmentKey The environment key, used to tie together flag configuration and users under one environment so they can be managed together.
     * @param {string} [q] Search query.
     * @param {number} [limit] Pagination limit.
     * @param {number} [offset] Specifies the first item to return in the collection.
     * @param {number} [after] A timestamp filter, expressed as a Unix epoch time in milliseconds. All entries returned will have occurred after this timestamp.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getSearchUsers(projectKey: string, environmentKey: string, q?: string, limit?: number, offset?: number, after?: number, options?: any) {
        return UsersApiFp(this.configuration).getSearchUsers(projectKey, environmentKey, q, limit, offset, after, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a user by key.
     * @param {string} projectKey The project key, used to tie the flags together under one project so they can be managed together.
     * @param {string} environmentKey The environment key, used to tie together flag configuration and users under one environment so they can be managed together.
     * @param {string} userKey The user\&#39;s key.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getUser(projectKey: string, environmentKey: string, userKey: string, options?: any) {
        return UsersApiFp(this.configuration).getUser(projectKey, environmentKey, userKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List all users in the environment. Includes the total count of users. In each page, there will be up to \'limit\' users returned (default 20). This is useful for exporting all users in the system for further analysis. Paginated collections will include a next link containing a URL with the next set of elements in the collection.
     * @param {string} projectKey The project key, used to tie the flags together under one project so they can be managed together.
     * @param {string} environmentKey The environment key, used to tie together flag configuration and users under one environment so they can be managed together.
     * @param {number} [limit] Pagination limit.
     * @param {string} [h] This parameter is required when following \&quot;next\&quot; links.
     * @param {string} [scrollId] This parameter is required when following \&quot;next\&quot; links.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getUsers(projectKey: string, environmentKey: string, limit?: number, h?: string, scrollId?: string, options?: any) {
        return UsersApiFp(this.configuration).getUsers(projectKey, environmentKey, limit, h, scrollId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * WebhooksApi - axios parameter creator
 * @export
 */
export const WebhooksApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Delete a webhook by ID.
         * @param {string} resourceId The resource ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWebhook: async (resourceId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'resourceId' is not null or undefined
            if (resourceId === null || resourceId === undefined) {
                throw new RequiredError('resourceId','Required parameter resourceId was null or undefined when calling deleteWebhook.');
            }
            const localVarPath = `/webhooks/{resourceId}`
                .replace(`{${"resourceId"}}`, encodeURIComponent(String(resourceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a webhook by ID.
         * @param {string} resourceId The resource ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebhook: async (resourceId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'resourceId' is not null or undefined
            if (resourceId === null || resourceId === undefined) {
                throw new RequiredError('resourceId','Required parameter resourceId was null or undefined when calling getWebhook.');
            }
            const localVarPath = `/webhooks/{resourceId}`
                .replace(`{${"resourceId"}}`, encodeURIComponent(String(resourceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Fetch a list of all webhooks.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebhooks: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/webhooks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Modify a webhook by ID.
         * @param {string} resourceId The resource ID.
         * @param {Array<PatchOperation>} patchDelta Requires a JSON Patch representation of the desired changes to the project. \&#39;http://jsonpatch.com/\&#39;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchWebhook: async (resourceId: string, patchDelta: Array<PatchOperation>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'resourceId' is not null or undefined
            if (resourceId === null || resourceId === undefined) {
                throw new RequiredError('resourceId','Required parameter resourceId was null or undefined when calling patchWebhook.');
            }
            // verify required parameter 'patchDelta' is not null or undefined
            if (patchDelta === null || patchDelta === undefined) {
                throw new RequiredError('patchDelta','Required parameter patchDelta was null or undefined when calling patchWebhook.');
            }
            const localVarPath = `/webhooks/{resourceId}`
                .replace(`{${"resourceId"}}`, encodeURIComponent(String(resourceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof patchDelta !== "string") && configuration.isJsonMime(localVarRequestOptions.headers['Content-Type']);
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(patchDelta !== undefined ? patchDelta : {}) : (patchDelta || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a webhook.
         * @param {InlineObject7} webhookBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postWebhook: async (webhookBody: InlineObject7, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'webhookBody' is not null or undefined
            if (webhookBody === null || webhookBody === undefined) {
                throw new RequiredError('webhookBody','Required parameter webhookBody was null or undefined when calling postWebhook.');
            }
            const localVarPath = `/webhooks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof webhookBody !== "string") && configuration.isJsonMime(localVarRequestOptions.headers['Content-Type']);
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(webhookBody !== undefined ? webhookBody : {}) : (webhookBody || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WebhooksApi - functional programming interface
 * @export
 */
export const WebhooksApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Delete a webhook by ID.
         * @param {string} resourceId The resource ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteWebhook(resourceId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await WebhooksApiAxiosParamCreator(configuration).deleteWebhook(resourceId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get a webhook by ID.
         * @param {string} resourceId The resource ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWebhook(resourceId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Webhook>> {
            const localVarAxiosArgs = await WebhooksApiAxiosParamCreator(configuration).getWebhook(resourceId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Fetch a list of all webhooks.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWebhooks(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Webhooks>> {
            const localVarAxiosArgs = await WebhooksApiAxiosParamCreator(configuration).getWebhooks(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Modify a webhook by ID.
         * @param {string} resourceId The resource ID.
         * @param {Array<PatchOperation>} patchDelta Requires a JSON Patch representation of the desired changes to the project. \&#39;http://jsonpatch.com/\&#39;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchWebhook(resourceId: string, patchDelta: Array<PatchOperation>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Webhook>> {
            const localVarAxiosArgs = await WebhooksApiAxiosParamCreator(configuration).patchWebhook(resourceId, patchDelta, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Create a webhook.
         * @param {InlineObject7} webhookBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postWebhook(webhookBody: InlineObject7, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Webhook>> {
            const localVarAxiosArgs = await WebhooksApiAxiosParamCreator(configuration).postWebhook(webhookBody, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * WebhooksApi - factory interface
 * @export
 */
export const WebhooksApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Delete a webhook by ID.
         * @param {string} resourceId The resource ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWebhook(resourceId: string, options?: any): AxiosPromise<void> {
            return WebhooksApiFp(configuration).deleteWebhook(resourceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a webhook by ID.
         * @param {string} resourceId The resource ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebhook(resourceId: string, options?: any): AxiosPromise<Webhook> {
            return WebhooksApiFp(configuration).getWebhook(resourceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Fetch a list of all webhooks.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebhooks(options?: any): AxiosPromise<Webhooks> {
            return WebhooksApiFp(configuration).getWebhooks(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Modify a webhook by ID.
         * @param {string} resourceId The resource ID.
         * @param {Array<PatchOperation>} patchDelta Requires a JSON Patch representation of the desired changes to the project. \&#39;http://jsonpatch.com/\&#39;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchWebhook(resourceId: string, patchDelta: Array<PatchOperation>, options?: any): AxiosPromise<Webhook> {
            return WebhooksApiFp(configuration).patchWebhook(resourceId, patchDelta, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a webhook.
         * @param {InlineObject7} webhookBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postWebhook(webhookBody: InlineObject7, options?: any): AxiosPromise<Webhook> {
            return WebhooksApiFp(configuration).postWebhook(webhookBody, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * WebhooksApi - object-oriented interface
 * @export
 * @class WebhooksApi
 * @extends {BaseAPI}
 */
export class WebhooksApi extends BaseAPI {
    /**
     * 
     * @summary Delete a webhook by ID.
     * @param {string} resourceId The resource ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApi
     */
    public deleteWebhook(resourceId: string, options?: any) {
        return WebhooksApiFp(this.configuration).deleteWebhook(resourceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a webhook by ID.
     * @param {string} resourceId The resource ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApi
     */
    public getWebhook(resourceId: string, options?: any) {
        return WebhooksApiFp(this.configuration).getWebhook(resourceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Fetch a list of all webhooks.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApi
     */
    public getWebhooks(options?: any) {
        return WebhooksApiFp(this.configuration).getWebhooks(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Modify a webhook by ID.
     * @param {string} resourceId The resource ID.
     * @param {Array<PatchOperation>} patchDelta Requires a JSON Patch representation of the desired changes to the project. \&#39;http://jsonpatch.com/\&#39;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApi
     */
    public patchWebhook(resourceId: string, patchDelta: Array<PatchOperation>, options?: any) {
        return WebhooksApiFp(this.configuration).patchWebhook(resourceId, patchDelta, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a webhook.
     * @param {InlineObject7} webhookBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApi
     */
    public postWebhook(webhookBody: InlineObject7, options?: any) {
        return WebhooksApiFp(this.configuration).postWebhook(webhookBody, options).then((request) => request(this.axios, this.basePath));
    }
}


